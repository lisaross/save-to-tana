{"version":3,"file":"options.js","sources":["../src/options.ts"],"sourcesContent":["import { TanaConfig, TanaFieldIds } from './types';\nimport { validateTargetNodeId } from './utils/validators';\n\n/**\n * Options page interfaces\n */\ninterface SchemaParseResult {\n  supertagId: string;\n  fieldIds: TanaFieldIds;\n}\n\n/**\n * Options page controller\n */\nexport class OptionsController {\n  // Form elements\n  private apiKeyInput: HTMLInputElement;\n  private targetNodeIdInput: HTMLInputElement;\n  private supertagIdInput: HTMLInputElement;\n  private saveButton: HTMLButtonElement;\n  private tanaSchemaInput: HTMLTextAreaElement;\n  private extractSchemaButton: HTMLButtonElement;\n  private extractedFieldsDiv: HTMLDivElement;\n  private extractedFieldIdsPre: HTMLPreElement;\n  private fieldIdUrlInput: HTMLInputElement;\n  private fieldIdAuthorInput: HTMLInputElement;\n  private fieldIdDescriptionInput: HTMLInputElement;\n  private fieldIdContentInput: HTMLInputElement;\n  private schemaErrorDiv: HTMLDivElement;\n  private toast: HTMLDivElement | null = null;\n\n  /**\n   * Initialize the options page controller\n   */\n  constructor() {\n    console.log('OptionsController constructor started');\n    \n    // Get form elements\n    this.apiKeyInput = document.getElementById('apiKey') as HTMLInputElement;\n    this.targetNodeIdInput = document.getElementById('targetNodeId') as HTMLInputElement;\n    this.supertagIdInput = document.getElementById('supertagId') as HTMLInputElement;\n    this.saveButton = document.getElementById('saveButton') as HTMLButtonElement;\n    this.tanaSchemaInput = document.getElementById('tanaSchema') as HTMLTextAreaElement;\n    this.extractSchemaButton = document.getElementById('extractSchemaButton') as HTMLButtonElement;\n    this.extractedFieldsDiv = document.getElementById('extractedFields') as HTMLDivElement;\n    this.extractedFieldIdsPre = document.getElementById('extractedFieldIds') as HTMLPreElement;\n    this.fieldIdUrlInput = document.getElementById('fieldIdUrl') as HTMLInputElement;\n    this.fieldIdAuthorInput = document.getElementById('fieldIdAuthor') as HTMLInputElement;\n    this.fieldIdDescriptionInput = document.getElementById('fieldIdDescription') as HTMLInputElement;\n    this.fieldIdContentInput = document.getElementById('fieldIdContent') as HTMLInputElement;\n    this.toast = document.getElementById('toast') as HTMLDivElement;\n    \n    // Debug log to check if elements were found\n    console.log('Extract schema button found:', !!this.extractSchemaButton);\n    console.log('Tana schema textarea found:', !!this.tanaSchemaInput);\n    console.log('All elements found:', {\n      apiKeyInput: !!this.apiKeyInput,\n      targetNodeIdInput: !!this.targetNodeIdInput,\n      supertagIdInput: !!this.supertagIdInput,\n      saveButton: !!this.saveButton,\n      tanaSchemaInput: !!this.tanaSchemaInput,\n      extractSchemaButton: !!this.extractSchemaButton,\n      extractedFieldsDiv: !!this.extractedFieldsDiv,\n      extractedFieldIdsPre: !!this.extractedFieldIdsPre,\n      toast: !!this.toast\n    });\n    \n    // Create schema error div\n    this.schemaErrorDiv = document.createElement('div');\n    this.schemaErrorDiv.className = 'status error';\n    this.schemaErrorDiv.style.display = 'none';\n    this.tanaSchemaInput.parentNode?.insertBefore(this.schemaErrorDiv, this.tanaSchemaInput.nextSibling);\n    \n    // Initialize the page\n    this.initializePage();\n  }\n\n  /**\n   * Initialize the options page\n   */\n  private initializePage(): void {\n    console.log('Initializing options page...');\n    \n    // Load saved configuration\n    this.loadConfiguration();\n    \n    // Add event listeners\n    this.saveButton.addEventListener('click', this.saveConfiguration.bind(this));\n    this.extractSchemaButton.addEventListener('click', () => {\n      console.log('Extract schema button clicked!');\n      this.extractSchemaFromTextarea();\n    });\n    \n    // Add input event listeners for validation\n    this.apiKeyInput.addEventListener('input', this.validateForm.bind(this));\n    this.targetNodeIdInput.addEventListener('input', this.validateForm.bind(this));\n    this.supertagIdInput.addEventListener('input', this.validateForm.bind(this));\n    this.fieldIdUrlInput.addEventListener('input', this.validateForm.bind(this));\n    this.fieldIdAuthorInput.addEventListener('input', this.validateForm.bind(this));\n    this.fieldIdDescriptionInput.addEventListener('input', this.validateForm.bind(this));\n    this.fieldIdContentInput.addEventListener('input', this.validateForm.bind(this));\n    \n    // Initialize example JSON toggle\n    this.initializeExampleJsonToggle();\n    \n    console.log('Options page initialization complete');\n  }\n\n  /**\n   * Initialize the example JSON toggle\n   */\n  private initializeExampleJsonToggle(): void {\n    const toggleBtn = document.getElementById('toggleExampleJson');\n    const exampleJsonBlock = document.getElementById('exampleJsonBlock');\n    const toggleLabel = document.getElementById('toggleExampleJsonLabel');\n\n    if (toggleBtn && exampleJsonBlock && toggleLabel) {\n      toggleBtn.addEventListener('click', () => {\n        const expanded = toggleBtn.getAttribute('aria-expanded') === 'true';\n        toggleBtn.setAttribute('aria-expanded', String(!expanded));\n        exampleJsonBlock.style.display = expanded ? 'none' : 'block';\n        toggleLabel.textContent = expanded ? 'Show Example JSON' : 'Hide Example JSON';\n      });\n    }\n  }\n\n  /**\n   * Load saved configuration from storage\n   */\n  private loadConfiguration(): void {\n    chrome.storage.sync.get(\n      ['apiKey', 'supertagId', 'targetNodeId', 'tanaFieldIds'], \n      (result: Partial<TanaConfig>) => {\n        console.log('Loaded configuration:', result);\n        \n        if (result.apiKey) {\n          this.apiKeyInput.value = result.apiKey;\n        }\n        \n        if (result.targetNodeId) {\n          this.targetNodeIdInput.value = result.targetNodeId;\n        }\n        \n        if (result.supertagId) {\n          this.supertagIdInput.value = result.supertagId;\n        }\n        \n        if (result.tanaFieldIds) {\n          this.fieldIdUrlInput.value = result.tanaFieldIds.URL || '';\n          this.fieldIdAuthorInput.value = result.tanaFieldIds.Author || '';\n          this.fieldIdDescriptionInput.value = result.tanaFieldIds.Description || '';\n          // Content field is commented out - using hierarchical content instead\n        }\n        \n        this.validateForm();\n      }\n    );\n  }\n\n  /**\n   * Save configuration to storage\n   */\n  private saveConfiguration(): void {\n    const rawTargetNodeId = this.targetNodeIdInput.value.trim();\n    const supertagId = this.supertagIdInput.value.trim();\n    const tanaFieldIds: TanaFieldIds = {\n      URL: this.fieldIdUrlInput.value.trim(),\n      Author: this.fieldIdAuthorInput.value.trim(),\n      Description: this.fieldIdDescriptionInput.value.trim(),\n      // Content field is commented out - using hierarchical content instead\n    };\n    \n    // Validate and extract target node ID\n    const nodeIdValidation = validateTargetNodeId(rawTargetNodeId);\n    if (!nodeIdValidation.success) {\n      this.showToast(nodeIdValidation.error || 'Invalid target node ID', true);\n      return;\n    }\n    \n    const apiKey = this.apiKeyInput.value.trim();\n    const targetNodeId = nodeIdValidation.nodeId!; // We know it's valid from the check above\n    \n    // Validate required fields\n    if (!apiKey) {\n      this.showToast('API Token is required', true);\n      return;\n    }\n    \n    if (!supertagId) {\n      this.showToast('Save to Tana Supertag ID is required. Please extract schema.', true);\n      return;\n    }\n    \n    if (!tanaFieldIds.URL || !tanaFieldIds.Author || !tanaFieldIds.Description) {\n      this.showToast('URL, Author, and Description field IDs are required.', true);\n      return;\n    }\n    \n    // Save configuration to storage\n    chrome.storage.sync.set({\n      apiKey,\n      targetNodeId,\n      supertagId,\n      tanaFieldIds\n    }, () => {\n      this.showToast('Configuration saved successfully!');\n    });\n  }\n\n  /**\n   * Validate the form and update UI\n   */\n  private validateForm(): void {\n    const apiKey = this.apiKeyInput.value.trim();\n    const targetNodeId = this.targetNodeIdInput.value.trim();\n    const supertagId = this.supertagIdInput.value.trim();\n    \n    // Enable save button if we have all required fields\n    this.saveButton.disabled = !apiKey || !targetNodeId || !supertagId;\n  }\n\n  /**\n   * Show a toast message\n   * @param message - Message to display\n   * @param isError - Whether this is an error message\n   */\n  private showToast(message: string, isError = false): void {\n    if (!this.toast) return;\n    \n    this.toast.textContent = message;\n    this.toast.className = 'toast' + (isError ? ' error' : ' success') + ' show';\n    \n    setTimeout(() => {\n      if (this.toast) {\n        this.toast.textContent = '';\n        this.toast.className = 'toast';\n      }\n    }, 3000);\n  }\n\n  /**\n   * Extract schema from textarea\n   */\n  private extractSchemaFromTextarea(): void {\n    console.log('extractSchemaFromTextarea called');\n    \n    this.schemaErrorDiv.style.display = 'none';\n    this.schemaErrorDiv.textContent = '';\n    \n    const raw = this.tanaSchemaInput.value;\n    console.log('Raw textarea value:', raw ? `${raw.length} characters` : 'empty');\n    \n    let schema;\n    \n    try {\n      schema = JSON.parse(raw);\n      console.log('JSON parsed successfully:', schema);\n    } catch (e) {\n      const error = e as Error;\n      console.error('JSON parsing failed:', error);\n      this.schemaErrorDiv.textContent = 'Could not parse JSON. Please paste the API payload as copied from Tana. Error: ' + error.message;\n      this.schemaErrorDiv.style.display = 'block';\n      this.extractedFieldsDiv.style.display = 'none';\n      return;\n    }\n    \n    try {\n      const result = this.extractSchemaInfo(schema);\n      \n      // Fill the inputs\n      this.supertagIdInput.value = result.supertagId;\n      this.fieldIdUrlInput.value = result.fieldIds.URL || '';\n      this.fieldIdAuthorInput.value = result.fieldIds.Author || '';\n      this.fieldIdDescriptionInput.value = result.fieldIds.Description || '';\n      // Content field is commented out - using hierarchical content instead\n      \n      // Show extracted info as a labeled list\n      this.extractedFieldsDiv.style.display = 'block';\n      this.extractedFieldIdsPre.innerHTML =\n        'Supertag ID: ' + result.supertagId + '\\n' +\n        Object.entries(result.fieldIds).map(([k, v]) => `${k} ID: ${v}`).join('\\n');\n      \n      // Store in chrome.storage, preserving current form values for apiKey and targetNodeId\n      const currentApiKey = this.apiKeyInput.value.trim();\n      const currentTargetNodeId = this.targetNodeIdInput.value.trim();\n      \n      // Validate current target node ID if provided\n      let validatedTargetNodeId = '';\n      if (currentTargetNodeId) {\n        const nodeIdValidation = validateTargetNodeId(currentTargetNodeId);\n        if (nodeIdValidation.success) {\n          validatedTargetNodeId = nodeIdValidation.nodeId!;\n        } else {\n          this.showToast(`Invalid target node ID: ${nodeIdValidation.error}`, true);\n          return;\n        }\n      }\n      \n      chrome.storage.sync.get(['apiKey', 'targetNodeId'], (existing) => {\n        chrome.storage.sync.set({\n          apiKey: currentApiKey || existing.apiKey || '',\n          targetNodeId: validatedTargetNodeId || existing.targetNodeId || '',\n          supertagId: result.supertagId,\n          tanaFieldIds: result.fieldIds\n        }, () => {\n          this.showToast('Schema extracted and saved!');\n        });\n      });\n    } catch (e) {\n      const error = e as Error;\n      this.schemaErrorDiv.textContent = 'Failed to extract schema info: ' + error.message;\n      this.schemaErrorDiv.style.display = 'block';\n      this.extractedFieldsDiv.style.display = 'none';\n    }\n  }\n\n  /**\n   * Extract schema information from parsed JSON\n   * @param schema - Parsed schema JSON\n   * @returns Extracted schema information\n   */\n  private extractSchemaInfo(schema: any): SchemaParseResult {\n    // Assume first node in nodes array\n    const node = Array.isArray(schema.nodes) ? schema.nodes[0] : null;\n    if (!node) throw new Error('No nodes found in schema payload.');\n    \n    // Extract supertagId\n    const supertagId = node.supertags?.[0]?.id || '';\n    if (!supertagId) throw new Error('No supertag ID found in schema.');\n    \n    // Extract field IDs by name from children\n    const fieldIds: Partial<TanaFieldIds> = {};\n    \n    if (Array.isArray(node.children)) {\n      for (const child of node.children) {\n        if (child.type === 'field' && child.attributeId) {\n          if (child.children?.[0]?.dataType === 'url') {\n            fieldIds.URL = child.attributeId;\n          } else if (fieldIds.Author === undefined) {\n            fieldIds.Author = child.attributeId;\n          } else if (fieldIds.Description === undefined) {\n            fieldIds.Description = child.attributeId;\n          } else {\n            // Content field is commented out - using hierarchical content instead\n          }\n        }\n      }\n    }\n    \n    return {\n      supertagId,\n      fieldIds: fieldIds as TanaFieldIds\n    };\n  }\n\n  /**\n   * Clean and parse Tana schema from TypeScript-like format\n   * This is a utility function for testing and development\n   * @param sample - TypeScript-like schema definition\n   * @returns Cleaned JSON string\n   */\n  static cleanSchemaString(sample: string): string {\n    const lines = sample.split('\\n');\n    \n    // Remove type definition line and closing line\n    if (lines[0].trim().startsWith('type')) lines.shift();\n    if (lines[lines.length - 1].trim().replace(/[;\\s]/g, '') === '}') lines.pop();\n    \n    // Clean each line\n    let cleaned = lines\n      .map(line => line\n        .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')  // Remove block comments\n        .replace(/\\/\\/.*$/g, '')           // Remove line comments\n        .replace(/^\\s*\\w+\\??:.*;\\s*$/g, '') // Remove type definitions\n        .replace(/;/g, '')                 // Remove semicolons\n        .replace(/\\?/g, '')                // Remove optional markers\n        .replace(/'/g, '\"')                // Replace single quotes with double quotes\n        .trim()\n      )\n      .filter(line => line.length > 0)\n      .join('\\n');\n    \n    // Fix trailing commas and property names\n    cleaned = cleaned.replace(/,\\s*([\\]\\}])/g, '$1');\n    cleaned = cleaned.replace(/(^|[,{\\s])(\\w+):/g, '$1\"$2\":');\n    \n    // Ensure it's a valid JSON object\n    if (!cleaned.trim().startsWith('{')) cleaned = '{' + cleaned + '}';\n    \n    return cleaned;\n  }\n}\n\n// Initialize the options page when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n  new OptionsController();\n});\n"],"names":["OptionsController","toggleBtn","exampleJsonBlock","toggleLabel","expanded","result","rawTargetNodeId","supertagId","tanaFieldIds","nodeIdValidation","validateTargetNodeId","apiKey","targetNodeId","message","isError","raw","schema","e","error","k","v","currentApiKey","currentTargetNodeId","validatedTargetNodeId","existing","node","fieldIds","child","sample","lines","cleaned","line"],"mappings":"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"}