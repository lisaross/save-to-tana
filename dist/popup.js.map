{"version":3,"file":"popup.js","sources":["../src/popup.ts"],"sourcesContent":["import { SaveToTanaRequest } from 'types';\n\n/**\n * Popup controller interfaces\n */\ninterface ExtractOptions {\n  includeContent: boolean;\n  includeTitle: boolean;\n}\n\ninterface StatusMessage {\n  message: string;\n  isError: boolean;\n}\n\n/**\n * Popup controller for the Save to Tana extension\n */\nexport class PopupController {\n  // UI elements\n  private saveButton: HTMLButtonElement;\n  private statusDiv: HTMLDivElement;\n  private openOptionsLink: HTMLAnchorElement;\n  private includeContentCheckbox: HTMLInputElement;\n  private includeTitleCheckbox: HTMLInputElement;\n  private notConfiguredDiv: HTMLDivElement;\n  private progressContainer: HTMLDivElement;\n  private progressFill: HTMLDivElement;\n  private progressText: HTMLDivElement;\n  \n  // State\n  private progressInterval: number | null = null;\n\n  /**\n   * Initialize the popup controller\n   */\n  constructor() {\n    // Get UI elements\n    this.saveButton = document.getElementById('save-button') as HTMLButtonElement;\n    this.statusDiv = document.getElementById('status') as HTMLDivElement;\n    this.openOptionsLink = document.getElementById('open-options') as HTMLAnchorElement;\n    this.includeContentCheckbox = document.getElementById('include-content') as HTMLInputElement;\n    this.includeTitleCheckbox = document.getElementById('include-title') as HTMLInputElement;\n    this.notConfiguredDiv = document.getElementById('not-configured') as HTMLDivElement;\n    this.progressContainer = document.getElementById('progress-container') as HTMLDivElement;\n    this.progressFill = document.getElementById('progress-fill') as HTMLDivElement;\n    this.progressText = document.getElementById('progress-text') as HTMLDivElement;\n    \n    // Initialize the popup\n    this.initializePopup();\n  }\n\n  /**\n   * Initialize the popup\n   */\n  private initializePopup(): void {\n    // Check if extension is configured\n    this.checkConfiguration();\n    \n    // Set up event listeners\n    this.openOptionsLink.addEventListener('click', this.openOptions.bind(this));\n    this.saveButton.addEventListener('click', this.saveToTana.bind(this));\n  }\n\n  /**\n   * Check if the extension is configured\n   */\n  private checkConfiguration(): void {\n    chrome.storage.sync.get(\n      ['apiKey', 'supertagId', 'targetNodeId'], \n      (result) => {\n        if (!result.apiKey || !result.supertagId || !result.targetNodeId) {\n          this.saveButton.disabled = true;\n          this.notConfiguredDiv.style.display = 'block';\n        }\n      }\n    );\n  }\n\n  /**\n   * Open the options page\n   */\n  private openOptions(): void {\n    chrome.runtime.openOptionsPage();\n  }\n\n  /**\n   * Save the current page to Tana\n   */\n  private saveToTana(): void {\n    this.saveButton.disabled = true;\n    this.saveButton.textContent = 'Saving...';\n    this.updateStatus({ message: '', isError: false });\n    this.showProgress('Extracting content...');\n    \n    const options: ExtractOptions = {\n      includeContent: this.includeContentCheckbox.checked,\n      includeTitle: this.includeTitleCheckbox.checked\n    };\n    \n    // Get the current tab\n    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n      const currentTab = tabs[0];\n      if (!currentTab.id) {\n        this.handleError('Cannot access the current tab.');\n        return;\n      }\n      \n      // Extract content from the page\n      this.extractContentFromPage(currentTab.id, options);\n    });\n  }\n\n  /**\n   * Extract content from the page\n   * @param tabId - ID of the tab to extract content from\n   * @param options - Extraction options\n   */\n  private extractContentFromPage(tabId: number, options: ExtractOptions): void {\n    // First, try to inject the content script to ensure it's loaded\n    this.ensureContentScriptLoaded(tabId)\n      .then(() => {\n        // Now try to communicate with the content script\n        chrome.tabs.sendMessage(\n          tabId, \n          {\n            action: 'extractContent',\n            options: options\n          }, \n          (response) => {\n            if (chrome.runtime.lastError) {\n              this.handleError('Error communicating with the page: ' + chrome.runtime.lastError.message);\n              return;\n            }\n            \n            if (!response) {\n              this.handleError('No response from the page. Please refresh and try again.');\n              return;\n            }\n            \n            if (response.error) {\n              this.handleError(response.message || 'Error extracting content from the page');\n              return;\n            }\n            \n            // Update progress\n            this.updateProgress(25, 'Content extracted, sending to Tana...');\n            \n            // Send data to background script\n            this.sendToBackground(response);\n          }\n        );\n      })\n      .catch((error) => {\n        console.log('Content script injection failed, trying fallback method:', error.message);\n        this.updateProgress(15, 'Trying alternative extraction method...');\n        \n        // Try fallback extraction method\n        this.extractContentWithFallback(tabId, options)\n          .then((data) => {\n            this.updateProgress(25, 'Content extracted, sending to Tana...');\n            this.sendToBackground(data);\n          })\n          .catch((fallbackError) => {\n            this.handleError('Failed to extract content: ' + error.message + '. Please refresh the page and try again.');\n          });\n      });\n  }\n\n  /**\n   * Ensure content script is loaded in the tab\n   * @param tabId - ID of the tab\n   * @returns Promise that resolves when content script is ready\n   */\n  private async ensureContentScriptLoaded(tabId: number): Promise<void> {\n    return new Promise((resolve, reject) => {\n      // First, try to ping the existing content script\n      chrome.tabs.sendMessage(tabId, { action: 'ping' }, (response) => {\n        if (chrome.runtime.lastError) {\n          // Content script not loaded, try to inject it\n          console.log('Content script not found, attempting injection...');\n          \n          // Get tab info to check if injection is possible\n          chrome.tabs.get(tabId, (tab) => {\n            if (chrome.runtime.lastError) {\n              reject(new Error('Cannot access tab information'));\n              return;\n            }\n            \n            // Check if this is a restricted page\n            if (tab.url?.startsWith('chrome://') || \n                tab.url?.startsWith('chrome-extension://') || \n                tab.url?.startsWith('edge://') || \n                tab.url?.startsWith('moz-extension://') ||\n                tab.url?.startsWith('about:')) {\n              reject(new Error('Cannot inject content script on this type of page. Please try on a regular webpage.'));\n              return;\n            }\n            \n            chrome.scripting.executeScript({\n              target: { tabId: tabId },\n              files: ['content.js']\n            }, (results) => {\n              if (chrome.runtime.lastError) {\n                reject(new Error('Failed to inject content script: ' + chrome.runtime.lastError.message));\n                return;\n              }\n              \n              // Try multiple times with increasing delays to ensure script loads\n              let attempts = 0;\n              const maxAttempts = 5;\n              const testContentScript = () => {\n                attempts++;\n                const delay = attempts * 200; // 200ms, 400ms, 600ms, 800ms, 1000ms\n                \n                setTimeout(() => {\n                  chrome.tabs.sendMessage(tabId, { action: 'ping' }, (pingResponse) => {\n                    if (chrome.runtime.lastError) {\n                      if (attempts < maxAttempts) {\n                        console.log(`Content script ping attempt ${attempts} failed, retrying...`);\n                        testContentScript();\n                      } else {\n                        // Check if it's a page that might block content scripts\n                        chrome.tabs.get(tabId, (tabInfo) => {\n                          const url = tabInfo.url || '';\n                          if (url.includes('accounts.google.com') || \n                              url.includes('login.') || \n                              url.includes('auth.') ||\n                              url.includes('secure.')) {\n                            reject(new Error('This page blocks content scripts for security. Please try on a different page.'));\n                          } else {\n                            reject(new Error('Content script injection failed. Please refresh the page and try again.'));\n                          }\n                        });\n                      }\n                    } else {\n                      console.log(`Content script responding after ${attempts} attempts`);\n                      resolve();\n                    }\n                  });\n                }, delay);\n              };\n              \n              // Start testing\n              testContentScript();\n            });\n          });\n        } else {\n          // Content script is already loaded and responding\n          console.log('Content script already loaded and responding');\n          resolve();\n        }\n      });\n    });\n  }\n\n  /**\n   * Fallback content extraction method using chrome.scripting\n   * @param tabId - ID of the tab\n   * @param options - Extraction options\n   * @returns Promise with extracted data\n   */\n  private async extractContentWithFallback(tabId: number, options: ExtractOptions): Promise<any> {\n    return new Promise((resolve, reject) => {\n      // Execute extraction code directly in the page\n      chrome.scripting.executeScript({\n        target: { tabId: tabId },\n        func: (extractOptions: any) => {\n          // Basic extraction function that runs directly in the page\n          try {\n            const pageData: any = {\n              url: window.location.href,\n              title: document.title,\n              author: '',\n              description: '',\n              content: '',\n              hierarchicalNodes: []\n            };\n            \n            // Extract author from meta tags\n            const authorMeta = document.querySelector('meta[name=\"author\"]') || \n                              document.querySelector('meta[property=\"article:author\"]');\n            if (authorMeta) {\n              pageData.author = authorMeta.getAttribute('content') || '';\n            }\n            \n            // Extract description from meta tags\n            const descMeta = document.querySelector('meta[name=\"description\"]') || \n                            document.querySelector('meta[property=\"og:description\"]');\n            if (descMeta) {\n              pageData.description = descMeta.getAttribute('content') || '';\n            }\n            \n            // Basic content extraction if requested\n            if (extractOptions.includeContent) {\n              // Try to find main content area\n              const main = document.querySelector('main') || \n                          document.querySelector('[role=\"main\"]') || \n                          document.querySelector('.main-content') ||\n                          document.querySelector('#main-content') ||\n                          document.querySelector('.content') ||\n                          document.body;\n              \n              if (main) {\n                // Extract text content from paragraphs and headings\n                const contentElements = main.querySelectorAll('h1, h2, h3, h4, h5, h6, p, li');\n                const contentNodes: any[] = [];\n                \n                for (const element of contentElements) {\n                  const text = element.textContent?.trim();\n                  if (text && text.length > 10) {\n                    contentNodes.push({ name: text });\n                  }\n                }\n                \n                if (contentNodes.length > 0) {\n                  pageData.hierarchicalNodes = [{\n                    name: pageData.title || 'Page Content',\n                    supertags: [],\n                    children: contentNodes\n                  }];\n                }\n              }\n            }\n            \n            // Handle title option\n            if (!extractOptions.includeTitle || !pageData.title) {\n              pageData.title = pageData.url;\n            }\n            \n            // Sanitize title\n            if (pageData.title) {\n              pageData.title = pageData.title.replace(/\\r?\\n|\\r/g, ' ').trim();\n            }\n            \n            return pageData;\n          } catch (error) {\n            return {\n              url: window.location.href,\n              title: document.title,\n              author: '',\n              description: '',\n              content: '',\n              error: true,\n              message: 'Fallback extraction failed: ' + (error instanceof Error ? error.message : 'Unknown error')\n            };\n          }\n        },\n        args: [options]\n      }, (results) => {\n        if (chrome.runtime.lastError) {\n          reject(new Error('Fallback extraction failed: ' + chrome.runtime.lastError.message));\n          return;\n        }\n        \n        if (!results || !results[0] || !results[0].result) {\n          reject(new Error('No data extracted from fallback method'));\n          return;\n        }\n        \n        const data = results[0].result as any;\n        if (data.error) {\n          reject(new Error(data.message || 'Fallback extraction error'));\n          return;\n        }\n        \n        resolve(data);\n      });\n    });\n  }\n\n  /**\n   * Send extracted data to the background script\n   * @param data - Extracted data to send\n   */\n  private sendToBackground(data: any): void {\n    const request: SaveToTanaRequest = {\n      action: 'saveToTana',\n      data: data\n    };\n    \n    // Estimate if this will be chunked based on content size\n    const estimatedSize = JSON.stringify(data).length;\n    const willBeChunked = estimatedSize > 4500;\n    \n    if (willBeChunked) {\n      // For chunked content, show more realistic progress updates\n      this.updateProgress(30, 'Preparing large content for upload...');\n      \n      // Simulate progress updates for chunked content\n      let progressPercent = 30;\n      this.progressInterval = window.setInterval(() => {\n        if (progressPercent < 85) {\n          progressPercent += 5;\n          this.updateProgress(progressPercent, 'Uploading content chunks...');\n        }\n      }, 800); // Update every 800ms\n      \n      chrome.runtime.sendMessage(request, (result) => {\n        this.clearProgressInterval();\n        this.handleBackgroundResponse(result, willBeChunked);\n      });\n    } else {\n      // For simple content, quick progress\n      this.updateProgress(50, 'Uploading to Tana...');\n      \n      chrome.runtime.sendMessage(request, (result) => {\n        this.handleBackgroundResponse(result, willBeChunked);\n      });\n    }\n  }\n\n  /**\n   * Handle response from background script\n   * @param result - Response from background script\n   * @param wasChunked - Whether content was chunked\n   */\n  private handleBackgroundResponse(result: any, wasChunked: boolean): void {\n    // Reset button\n    this.saveButton.disabled = false;\n    this.saveButton.textContent = 'Save to Tana';\n    \n    if (!result) {\n      this.handleError('No response from the extension. Please try again.');\n      return;\n    }\n    \n    if (!result.success) {\n      this.handleError(result.error || 'Unknown error occurred');\n      return;\n    }\n    \n    // Handle response with chunking information\n    this.updateProgress(100, 'Complete!');\n    \n    let successMessage = 'Saved to Tana successfully!';\n    if (result.data && result.data.contentChunks > 0) {\n      successMessage = `Saved to Tana successfully! (Content split into ${result.data.contentChunks} parts due to size)`;\n    }\n    \n    // Show success after a brief delay to let users see 100% completion\n    setTimeout(() => {\n      this.hideProgress();\n      this.showSuccess(successMessage);\n    }, 500);\n  }\n\n  /**\n   * Handle an error\n   * @param message - Error message\n   */\n  private handleError(message: string): void {\n    // Reset button\n    this.saveButton.disabled = false;\n    this.saveButton.textContent = 'Save to Tana';\n    \n    this.hideProgress();\n    this.updateStatus({ message, isError: true });\n  }\n\n  /**\n   * Show a success message\n   * @param message - Success message\n   */\n  private showSuccess(message: string): void {\n    this.updateStatus({ message, isError: false });\n    \n    // Clear status after 3 seconds\n    setTimeout(() => {\n      this.updateStatus({ message: '', isError: false });\n    }, 3000);\n  }\n\n  /**\n   * Update the status display\n   * @param status - Status message and type\n   */\n  private updateStatus(status: StatusMessage): void {\n    this.statusDiv.textContent = status.message;\n    this.statusDiv.className = 'status' + (status.isError ? ' error' : status.message ? ' success' : '');\n  }\n\n  /**\n   * Show progress bar\n   * @param text - Progress text to display\n   */\n  private showProgress(text: string = 'Processing...'): void {\n    this.progressContainer.style.display = 'block';\n    this.progressText.textContent = text;\n    this.progressFill.style.width = '0%';\n    this.updateStatus({ message: '', isError: false });\n  }\n\n  /**\n   * Update progress bar\n   * @param progress - Progress percentage (0-100)\n   * @param text - Progress text to display\n   */\n  private updateProgress(progress: number, text: string): void {\n    this.progressFill.style.width = `${Math.min(100, Math.max(0, progress))}%`;\n    this.progressText.textContent = text;\n  }\n\n  /**\n   * Hide progress bar\n   */\n  private hideProgress(): void {\n    this.clearProgressInterval();\n    this.progressContainer.style.display = 'none';\n  }\n\n  /**\n   * Clear progress interval if running\n   */\n  private clearProgressInterval(): void {\n    if (this.progressInterval !== null) {\n      window.clearInterval(this.progressInterval);\n      this.progressInterval = null;\n    }\n  }\n}\n\n// Initialize the popup when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n  new PopupController();\n});\n"],"names":["PopupController","result","options","tabs","currentTab","tabId","response","error","data","fallbackError","resolve","reject","tab","results","attempts","maxAttempts","testContentScript","delay","pingResponse","tabInfo","url","extractOptions","pageData","authorMeta","descMeta","main","contentElements","contentNodes","element","text","request","willBeChunked","progressPercent","wasChunked","successMessage","message","status","progress"],"mappings":"AAkBO,MAAMA,CAAgB,CAEnB,WACA,UACA,gBACA,uBACA,qBACA,iBACA,kBACA,aACA,aAGA,iBAAkC,KAK1C,aAAc,CAEP,KAAA,WAAa,SAAS,eAAe,aAAa,EAClD,KAAA,UAAY,SAAS,eAAe,QAAQ,EAC5C,KAAA,gBAAkB,SAAS,eAAe,cAAc,EACxD,KAAA,uBAAyB,SAAS,eAAe,iBAAiB,EAClE,KAAA,qBAAuB,SAAS,eAAe,eAAe,EAC9D,KAAA,iBAAmB,SAAS,eAAe,gBAAgB,EAC3D,KAAA,kBAAoB,SAAS,eAAe,oBAAoB,EAChE,KAAA,aAAe,SAAS,eAAe,eAAe,EACtD,KAAA,aAAe,SAAS,eAAe,eAAe,EAG3D,KAAK,gBAAgB,CAAA,CAMf,iBAAwB,CAE9B,KAAK,mBAAmB,EAGxB,KAAK,gBAAgB,iBAAiB,QAAS,KAAK,YAAY,KAAK,IAAI,CAAC,EAC1E,KAAK,WAAW,iBAAiB,QAAS,KAAK,WAAW,KAAK,IAAI,CAAC,CAAA,CAM9D,oBAA2B,CACjC,OAAO,QAAQ,KAAK,IAClB,CAAC,SAAU,aAAc,cAAc,EACtCC,GAAW,EACN,CAACA,EAAO,QAAU,CAACA,EAAO,YAAc,CAACA,EAAO,gBAClD,KAAK,WAAW,SAAW,GACtB,KAAA,iBAAiB,MAAM,QAAU,QACxC,CAEJ,CAAA,CAMM,aAAoB,CAC1B,OAAO,QAAQ,gBAAgB,CAAA,CAMzB,YAAmB,CACzB,KAAK,WAAW,SAAW,GAC3B,KAAK,WAAW,YAAc,YAC9B,KAAK,aAAa,CAAE,QAAS,GAAI,QAAS,GAAO,EACjD,KAAK,aAAa,uBAAuB,EAEzC,MAAMC,EAA0B,CAC9B,eAAgB,KAAK,uBAAuB,QAC5C,aAAc,KAAK,qBAAqB,OAC1C,EAGO,OAAA,KAAK,MAAM,CAAE,OAAQ,GAAM,cAAe,IAASC,GAAS,CAC3D,MAAAC,EAAaD,EAAK,CAAC,EACrB,GAAA,CAACC,EAAW,GAAI,CAClB,KAAK,YAAY,gCAAgC,EACjD,MAAA,CAIG,KAAA,uBAAuBA,EAAW,GAAIF,CAAO,CAAA,CACnD,CAAA,CAQK,uBAAuBG,EAAeH,EAA+B,CAE3E,KAAK,0BAA0BG,CAAK,EACjC,KAAK,IAAM,CAEV,OAAO,KAAK,YACVA,EACA,CACE,OAAQ,iBACR,QAAAH,CACF,EACCI,GAAa,CACR,GAAA,OAAO,QAAQ,UAAW,CAC5B,KAAK,YAAY,sCAAwC,OAAO,QAAQ,UAAU,OAAO,EACzF,MAAA,CAGF,GAAI,CAACA,EAAU,CACb,KAAK,YAAY,0DAA0D,EAC3E,MAAA,CAGF,GAAIA,EAAS,MAAO,CACb,KAAA,YAAYA,EAAS,SAAW,wCAAwC,EAC7E,MAAA,CAIG,KAAA,eAAe,GAAI,uCAAuC,EAG/D,KAAK,iBAAiBA,CAAQ,CAAA,CAElC,CAAA,CACD,EACA,MAAOC,GAAU,CACR,QAAA,IAAI,2DAA4DA,EAAM,OAAO,EAChF,KAAA,eAAe,GAAI,yCAAyC,EAGjE,KAAK,2BAA2BF,EAAOH,CAAO,EAC3C,KAAMM,GAAS,CACT,KAAA,eAAe,GAAI,uCAAuC,EAC/D,KAAK,iBAAiBA,CAAI,CAAA,CAC3B,EACA,MAAOC,GAAkB,CACxB,KAAK,YAAY,8BAAgCF,EAAM,QAAU,0CAA0C,CAAA,CAC5G,CAAA,CACJ,CAAA,CAQL,MAAc,0BAA0BF,EAA8B,CACpE,OAAO,IAAI,QAAQ,CAACK,EAASC,IAAW,CAE/B,OAAA,KAAK,YAAYN,EAAO,CAAE,OAAQ,MAAO,EAAIC,GAAa,CAC3D,OAAO,QAAQ,WAEjB,QAAQ,IAAI,mDAAmD,EAG/D,OAAO,KAAK,IAAID,EAAQO,GAAQ,CAC1B,GAAA,OAAO,QAAQ,UAAW,CACrBD,EAAA,IAAI,MAAM,+BAA+B,CAAC,EACjD,MAAA,CAIE,GAAAC,EAAI,KAAK,WAAW,WAAW,GAC/BA,EAAI,KAAK,WAAW,qBAAqB,GACzCA,EAAI,KAAK,WAAW,SAAS,GAC7BA,EAAI,KAAK,WAAW,kBAAkB,GACtCA,EAAI,KAAK,WAAW,QAAQ,EAAG,CAC1BD,EAAA,IAAI,MAAM,qFAAqF,CAAC,EACvG,MAAA,CAGF,OAAO,UAAU,cAAc,CAC7B,OAAQ,CAAE,MAAAN,CAAa,EACvB,MAAO,CAAC,YAAY,CACtB,EAAIQ,GAAY,CACV,GAAA,OAAO,QAAQ,UAAW,CAC5BF,EAAO,IAAI,MAAM,oCAAsC,OAAO,QAAQ,UAAU,OAAO,CAAC,EACxF,MAAA,CAIF,IAAIG,EAAW,EACf,MAAMC,EAAc,EACdC,EAAoB,IAAM,CAC9BF,IACA,MAAMG,EAAQH,EAAW,IAEzB,WAAW,IAAM,CACR,OAAA,KAAK,YAAYT,EAAO,CAAE,OAAQ,MAAO,EAAIa,GAAiB,CAC/D,OAAO,QAAQ,UACbJ,EAAWC,GACL,QAAA,IAAI,+BAA+BD,CAAQ,sBAAsB,EACvDE,EAAA,GAGlB,OAAO,KAAK,IAAIX,EAAQc,GAAY,CAC5B,MAAAC,EAAMD,EAAQ,KAAO,GACvBC,EAAI,SAAS,qBAAqB,GAClCA,EAAI,SAAS,QAAQ,GACrBA,EAAI,SAAS,OAAO,GACpBA,EAAI,SAAS,SAAS,EACjBT,EAAA,IAAI,MAAM,gFAAgF,CAAC,EAE3FA,EAAA,IAAI,MAAM,yEAAyE,CAAC,CAC7F,CACD,GAGK,QAAA,IAAI,mCAAmCG,CAAQ,WAAW,EAC1DJ,EAAA,EACV,CACD,GACAO,CAAK,CACV,EAGkBD,EAAA,CAAA,CACnB,CAAA,CACF,IAGD,QAAQ,IAAI,8CAA8C,EAClDN,EAAA,EACV,CACD,CAAA,CACF,CAAA,CASH,MAAc,2BAA2BL,EAAeH,EAAuC,CAC7F,OAAO,IAAI,QAAQ,CAACQ,EAASC,IAAW,CAEtC,OAAO,UAAU,cAAc,CAC7B,OAAQ,CAAE,MAAAN,CAAa,EACvB,KAAOgB,GAAwB,CAEzB,GAAA,CACF,MAAMC,EAAgB,CACpB,IAAK,OAAO,SAAS,KACrB,MAAO,SAAS,MAChB,OAAQ,GACR,YAAa,GACb,QAAS,GACT,kBAAmB,CAAA,CACrB,EAGMC,EAAa,SAAS,cAAc,qBAAqB,GAC7C,SAAS,cAAc,iCAAiC,EACtEA,IACFD,EAAS,OAASC,EAAW,aAAa,SAAS,GAAK,IAI1D,MAAMC,EAAW,SAAS,cAAc,0BAA0B,GAClD,SAAS,cAAc,iCAAiC,EAMxE,GALIA,IACFF,EAAS,YAAcE,EAAS,aAAa,SAAS,GAAK,IAIzDH,EAAe,eAAgB,CAE3B,MAAAI,EAAO,SAAS,cAAc,MAAM,GAC9B,SAAS,cAAc,eAAe,GACtC,SAAS,cAAc,eAAe,GACtC,SAAS,cAAc,eAAe,GACtC,SAAS,cAAc,UAAU,GACjC,SAAS,KAErB,GAAIA,EAAM,CAEF,MAAAC,EAAkBD,EAAK,iBAAiB,+BAA+B,EACvEE,EAAsB,CAAC,EAE7B,UAAWC,KAAWF,EAAiB,CAC/B,MAAAG,EAAOD,EAAQ,aAAa,KAAK,EACnCC,GAAQA,EAAK,OAAS,IACxBF,EAAa,KAAK,CAAE,KAAME,CAAA,CAAM,CAClC,CAGEF,EAAa,OAAS,IACxBL,EAAS,kBAAoB,CAAC,CAC5B,KAAMA,EAAS,OAAS,eACxB,UAAW,CAAC,EACZ,SAAUK,CAAA,CACX,EACH,CACF,CAIF,OAAI,CAACN,EAAe,cAAgB,CAACC,EAAS,SAC5CA,EAAS,MAAQA,EAAS,KAIxBA,EAAS,QACXA,EAAS,MAAQA,EAAS,MAAM,QAAQ,YAAa,GAAG,EAAE,KAAK,GAG1DA,QACAf,EAAO,CACP,MAAA,CACL,IAAK,OAAO,SAAS,KACrB,MAAO,SAAS,MAChB,OAAQ,GACR,YAAa,GACb,QAAS,GACT,MAAO,GACP,QAAS,gCAAkCA,aAAiB,MAAQA,EAAM,QAAU,gBACtF,CAAA,CAEJ,EACA,KAAM,CAACL,CAAO,CAChB,EAAIW,GAAY,CACV,GAAA,OAAO,QAAQ,UAAW,CAC5BF,EAAO,IAAI,MAAM,+BAAiC,OAAO,QAAQ,UAAU,OAAO,CAAC,EACnF,MAAA,CAGE,GAAA,CAACE,GAAW,CAACA,EAAQ,CAAC,GAAK,CAACA,EAAQ,CAAC,EAAE,OAAQ,CAC1CF,EAAA,IAAI,MAAM,wCAAwC,CAAC,EAC1D,MAAA,CAGI,MAAAH,EAAOK,EAAQ,CAAC,EAAE,OACxB,GAAIL,EAAK,MAAO,CACdG,EAAO,IAAI,MAAMH,EAAK,SAAW,2BAA2B,CAAC,EAC7D,MAAA,CAGFE,EAAQF,CAAI,CAAA,CACb,CAAA,CACF,CAAA,CAOK,iBAAiBA,EAAiB,CACxC,MAAMsB,EAA6B,CACjC,OAAQ,aACR,KAAAtB,CACF,EAIMuB,EADgB,KAAK,UAAUvB,CAAI,EAAE,OACL,KAEtC,GAAIuB,EAAe,CAEZ,KAAA,eAAe,GAAI,uCAAuC,EAG/D,IAAIC,EAAkB,GACjB,KAAA,iBAAmB,OAAO,YAAY,IAAM,CAC3CA,EAAkB,KACDA,GAAA,EACd,KAAA,eAAeA,EAAiB,6BAA6B,IAEnE,GAAG,EAEN,OAAO,QAAQ,YAAYF,EAAU7B,GAAW,CAC9C,KAAK,sBAAsB,EACtB,KAAA,yBAAyBA,EAAQ8B,CAAa,CAAA,CACpD,CAAA,MAGI,KAAA,eAAe,GAAI,sBAAsB,EAE9C,OAAO,QAAQ,YAAYD,EAAU7B,GAAW,CACzC,KAAA,yBAAyBA,EAAQ8B,CAAa,CAAA,CACpD,CACH,CAQM,yBAAyB9B,EAAagC,EAA2B,CAKvE,GAHA,KAAK,WAAW,SAAW,GAC3B,KAAK,WAAW,YAAc,eAE1B,CAAChC,EAAQ,CACX,KAAK,YAAY,mDAAmD,EACpE,MAAA,CAGE,GAAA,CAACA,EAAO,QAAS,CACd,KAAA,YAAYA,EAAO,OAAS,wBAAwB,EACzD,MAAA,CAIG,KAAA,eAAe,IAAK,WAAW,EAEpC,IAAIiC,EAAiB,8BACjBjC,EAAO,MAAQA,EAAO,KAAK,cAAgB,IAC5BiC,EAAA,mDAAmDjC,EAAO,KAAK,aAAa,uBAI/F,WAAW,IAAM,CACf,KAAK,aAAa,EAClB,KAAK,YAAYiC,CAAc,GAC9B,GAAG,CAAA,CAOA,YAAYC,EAAuB,CAEzC,KAAK,WAAW,SAAW,GAC3B,KAAK,WAAW,YAAc,eAE9B,KAAK,aAAa,EAClB,KAAK,aAAa,CAAE,QAAAA,EAAS,QAAS,GAAM,CAAA,CAOtC,YAAYA,EAAuB,CACzC,KAAK,aAAa,CAAE,QAAAA,EAAS,QAAS,GAAO,EAG7C,WAAW,IAAM,CACf,KAAK,aAAa,CAAE,QAAS,GAAI,QAAS,GAAO,GAChD,GAAI,CAAA,CAOD,aAAaC,EAA6B,CAC3C,KAAA,UAAU,YAAcA,EAAO,QAC/B,KAAA,UAAU,UAAY,UAAYA,EAAO,QAAU,SAAWA,EAAO,QAAU,WAAa,GAAA,CAO3F,aAAaP,EAAe,gBAAuB,CACpD,KAAA,kBAAkB,MAAM,QAAU,QACvC,KAAK,aAAa,YAAcA,EAC3B,KAAA,aAAa,MAAM,MAAQ,KAChC,KAAK,aAAa,CAAE,QAAS,GAAI,QAAS,GAAO,CAAA,CAQ3C,eAAeQ,EAAkBR,EAAoB,CAC3D,KAAK,aAAa,MAAM,MAAQ,GAAG,KAAK,IAAI,IAAK,KAAK,IAAI,EAAGQ,CAAQ,CAAC,CAAC,IACvE,KAAK,aAAa,YAAcR,CAAA,CAM1B,cAAqB,CAC3B,KAAK,sBAAsB,EACtB,KAAA,kBAAkB,MAAM,QAAU,MAAA,CAMjC,uBAA8B,CAChC,KAAK,mBAAqB,OACrB,OAAA,cAAc,KAAK,gBAAgB,EAC1C,KAAK,iBAAmB,KAC1B,CAEJ,CAGA,SAAS,iBAAiB,mBAAoB,IAAM,CAClD,IAAI7B,CACN,CAAC"}