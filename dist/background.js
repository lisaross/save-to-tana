import{s as w}from"./textUtils-DJNAmfRs.js";function y(e,t,o,n){if(!e)throw new Error("SaveData is required");if(!t||!t.trim())throw new Error("Valid targetNodeId is required");if(!o||!o.trim())throw new Error("Valid supertagId is required");if(!n)throw new Error("TanaFieldIds is required");const r={name:w(e.title||e.url),supertags:[{id:o}],children:[]};return e.url&&n.URL&&r.children.push({type:"field",attributeId:n.URL,children:[{dataType:"url",name:e.url}]}),e.author&&n.Author&&r.children.push({type:"field",attributeId:n.Author,children:[{name:w(e.author)}]}),e.description&&n.Description&&r.children.push({type:"field",attributeId:n.Description,children:[{name:w(e.description)}]}),{targetNodeId:t,nodes:[r]}}const x={maxPayloadSize:4500,maxNodesPerChunk:90,maxChildrenPerNode:50};function I(e){return JSON.stringify(e).length}function P(e){function t(o){let n=1;if("children"in o&&Array.isArray(o.children))for(const r of o.children)n+=t(r);return n}return e.nodes.reduce((o,n)=>o+t(n),0)}function k(e,t){const o=[];let n=[];for(const r of e){const s={targetNodeId:"test",nodes:[{name:"Test",supertags:[],children:[...n,r]}]},i=JSON.stringify(s).length>t.maxPayloadSize,u=n.length>=t.maxChildrenPerNode;if((i||u)&&n.length>0&&(o.push([...n]),n=[]),"children"in r&&Array.isArray(r.children)&&r.children.length>0)if(JSON.stringify(r).length>t.maxPayloadSize*.8){const d=k(r.children,t);for(let g=0;g<d.length;g++){const c={...r,name:"name"in r?r.name:"Content",children:d[g]},m={targetNodeId:"test",nodes:[{name:"Test",supertags:[],children:[...n,c]}]};JSON.stringify(m).length>t.maxPayloadSize&&n.length>0&&(o.push([...n]),n=[]),n.push(c)}}else n.push(r);else n.push(r)}return n.length>0&&o.push(n),o.length>0?o:[[]]}function C(e,t=x){const o=I(e),n=P(e);if(o<=t.maxPayloadSize&&n<=t.maxNodesPerChunk)return[e];const r=[];for(const s of e.nodes){if(!s.children||s.children.length===0){const a={targetNodeId:e.targetNodeId,nodes:[{...s}]};r.push(a);continue}const h=[],i=[];for(const a of s.children)"type"in a&&a.type==="field"?h.push(a):i.push(a);if(i.length===0){const a={targetNodeId:e.targetNodeId,nodes:[{...s,children:h}]};r.push(a);continue}const u=k(i,t);for(let a=0;a<u.length;a++){const d={...s,name:s.name,children:u[a]},g={targetNodeId:e.targetNodeId,nodes:[d]},c=I(g),m=P(g);(c>t.maxPayloadSize||m>t.maxNodesPerChunk)&&console.warn(`Chunk ${a+1} still exceeds limits: ${c} chars, ${m} nodes`),r.push(g)}}return r.length>0?r:[e]}chrome.runtime.onInstalled.addListener(()=>{console.log("Save to Tana extension installed")});chrome.runtime.onMessage.addListener((e,t,o)=>e.action==="saveToTana"?($(e.data).then(n=>{o(n)}).catch(n=>{o({success:!1,error:n instanceof Error?n.message:"Unknown error occurred"})}),!0):!1);async function $(e){try{console.log("Starting saveToTana with data:",e);const t=await D();console.log("Retrieved configuration from storage:",t),T(t);const o=t.targetNodeId;console.log("Using target node ID:",o);const n=y(e,o,t.supertagId,t.tanaFieldIds);if(console.log("Formatted Tana payload:",n),e.hierarchicalNodes&&e.hierarchicalNodes.length>0&&n.nodes.length>0){const d=e.hierarchicalNodes[0].children||[];n.nodes[0].children.push(...d),console.log("Added content nodes:",d.length)}const r=JSON.stringify(n).length;if(!(r>4500))return console.log(`Payload size: ${r} chars - sending as single request`),{success:!0,data:await f(n,t.apiKey)};console.log(`Large content detected (${r} chars). Using hierarchical chunking strategy.`);const h=y(e,o,t.supertagId,t.tanaFieldIds);console.log("Sending main node with metadata...");const i=await f(h,t.apiKey),u=i.children?.[0]?.nodeId;if(!u)throw new Error("Could not get node ID from main node creation response");if(console.log(`Main node created with ID: ${u}`),await new Promise(d=>setTimeout(d,1e3)),e.hierarchicalNodes&&e.hierarchicalNodes.length>0){const d=e.hierarchicalNodes[0].children||[],g={targetNodeId:u,nodes:d.map(l=>({name:("name"in l?l.name:"Content")||"Content",supertags:[],children:l.children||[]}))},c=C(g);console.log(`Chunked content into ${c.length} parts`);const m=[];for(let l=0;l<c.length;l++){const N=c[l];console.log(`Sending content chunk ${l+1}/${c.length} (${JSON.stringify(N).length} chars)`);try{const p=await f(N,t.apiKey);m.push(p),l<c.length-1&&await new Promise(S=>setTimeout(S,1500))}catch(p){throw console.error(`Error sending content chunk ${l+1}:`,p),p instanceof Error&&p.message.includes("429")?new Error(`Rate limit exceeded while sending chunk ${l+1}/${c.length}. Please wait a moment and try again.`):new Error(`Failed to send content chunk ${l+1}/${c.length}: ${p}`)}}return{success:!0,data:{mainNode:i,contentChunks:m.length,responses:[i,...m]}}}return{success:!0,data:{mainNode:i,contentChunks:0,responses:[i]}}}catch(t){throw console.error("Error saving to Tana:",t),t}}async function D(){return new Promise((e,t)=>{chrome.storage.sync.get(["apiKey","targetNodeId","supertagId","tanaFieldIds"],o=>{try{T(o),e(o)}catch(n){t(n)}})})}function T(e){if(!e.apiKey)throw new Error("API Token not configured. Please go to extension options and set up your configuration.");if(!e.supertagId)throw new Error("Supertag ID not configured. Please extract and save your Tana schema in options.");if(!e.targetNodeId)throw new Error("Target Node ID is required. Please go to options and specify a target node ID.");if(!e.tanaFieldIds)throw new Error("Field IDs not configured. Please extract and save your Tana schema in options.")}async function f(e,t,o=0){console.log(`Sending request to Tana API (attempt ${o+1})...`);try{const s=await fetch("https://europe-west1-tagr-prod.cloudfunctions.net/addToNodeV2",{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${t}`},body:JSON.stringify(e)});if(console.log("API response status:",s.status),!s.ok){const i=await s.text();if(console.error("API error response:",i),s.status===429&&o<3){const u=2e3*Math.pow(2,o);return console.log(`Rate limited. Retrying in ${u}ms...`),await new Promise(a=>setTimeout(a,u)),f(e,t,o+1)}throw new Error(`API error (${s.status}): ${i}`)}const h=await s.json();return console.log("API success response:",h),h}catch(s){if(o<3&&!(s instanceof Error&&s.message.includes("API error"))){const h=2e3*Math.pow(2,o);return console.log(`Network error. Retrying in ${h}ms...`),await new Promise(i=>setTimeout(i,h)),f(e,t,o+1)}throw s}}
//# sourceMappingURL=background.js.map
