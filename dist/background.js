function w(e){return e?e.replace(/\r?\n|\r/g," ").replace(/\s+/g," ").trim():""}function N(e,t,r,n){if(!e)throw new Error("SaveData is required");if(!t||!t.trim())throw new Error("Valid targetNodeId is required");if(!r||!r.trim())throw new Error("Valid supertagId is required");if(!n)throw new Error("TanaFieldIds is required");const o={name:w(e.title||e.url),supertags:[{id:r}],children:[]};return e.url&&n.URL&&o.children.push({type:"field",attributeId:n.URL,children:[{dataType:"url",name:e.url}]}),e.author&&n.Author&&o.children.push({type:"field",attributeId:n.Author,children:[{name:w(e.author)}]}),e.description&&n.Description&&o.children.push({type:"field",attributeId:n.Description,children:[{name:w(e.description)}]}),{targetNodeId:t,nodes:[o]}}const x={maxPayloadSize:4500,maxNodesPerChunk:90,maxChildrenPerNode:50};function I(e){return JSON.stringify(e).length}function k(e){function t(r){let n=1;if("children"in r&&Array.isArray(r.children))for(const o of r.children)n+=t(o);return n}return e.nodes.reduce((r,n)=>r+t(n),0)}function P(e,t){const r=[];let n=[];for(const o of e){const s={targetNodeId:"test",nodes:[{name:"Test",supertags:[],children:[...n,o]}]},c=JSON.stringify(s).length>t.maxPayloadSize,u=n.length>=t.maxChildrenPerNode;if((c||u)&&n.length>0&&(r.push([...n]),n=[]),"children"in o&&Array.isArray(o.children)&&o.children.length>0)if(JSON.stringify(o).length>t.maxPayloadSize*.8){const d=P(o.children,t);for(let i=0;i<d.length;i++){const g={...o,name:"name"in o?o.name:"Content",children:d[i]},p={targetNodeId:"test",nodes:[{name:"Test",supertags:[],children:[...n,g]}]};JSON.stringify(p).length>t.maxPayloadSize&&n.length>0&&(r.push([...n]),n=[]),n.push(g)}}else n.push(o);else n.push(o)}return n.length>0&&r.push(n),r.length>0?r:[[]]}function C(e,t=x){const r=I(e),n=k(e);if(r<=t.maxPayloadSize&&n<=t.maxNodesPerChunk)return[e];const o=[];for(const s of e.nodes){if(!s.children||s.children.length===0){const a={targetNodeId:e.targetNodeId,nodes:[{...s}]};o.push(a);continue}const h=[],c=[];for(const a of s.children)"type"in a&&a.type==="field"?h.push(a):c.push(a);if(c.length===0){const a={targetNodeId:e.targetNodeId,nodes:[{...s,children:h}]};o.push(a);continue}const u=P(c,t);for(let a=0;a<u.length;a++){const d={...s,name:s.name,children:u[a]},i={targetNodeId:e.targetNodeId,nodes:[d]},g=I(i),p=k(i);(g>t.maxPayloadSize||p>t.maxNodesPerChunk)&&console.warn(`Chunk ${a+1} still exceeds limits: ${g} chars, ${p} nodes`),o.push(i)}}return o.length>0?o:[e]}chrome.runtime.onInstalled.addListener(()=>{console.log("Save to Tana extension installed")});chrome.runtime.onMessage.addListener((e,t,r)=>e.action==="saveToTana"?($(e.data).then(n=>{r(n)}).catch(n=>{r({success:!1,error:n instanceof Error?n.message:"Unknown error occurred"})}),!0):!1);async function $(e){try{console.log("Starting saveToTana with data:",e);const t=await A();console.log("Retrieved configuration from storage:",t),T(t);const r=t.targetNodeId;console.log("Using target node ID:",r);const n=N(e,r,t.supertagId,t.tanaFieldIds);if(console.log("Formatted Tana payload:",n),e.hierarchicalNodes&&e.hierarchicalNodes.length>0&&n.nodes.length>0){const d=e.hierarchicalNodes[0].children.filter(i=>i.children&&Array.isArray(i.children)&&i.children.length>0);n.nodes[0].children.push(...d),console.log("Added hierarchical content nodes:",d.length)}const o=JSON.stringify(n).length;if(!(o>4500))return console.log(`Payload size: ${o} chars - sending as single request`),{success:!0,data:await f(n,t.apiKey)};console.log(`Large content detected (${o} chars). Using hierarchical chunking strategy.`);const h=N(e,r,t.supertagId,t.tanaFieldIds);console.log("Sending main node with metadata...");const c=await f(h,t.apiKey),u=c.children?.[0]?.nodeId;if(!u)throw new Error("Could not get node ID from main node creation response");if(console.log(`Main node created with ID: ${u}`),await new Promise(d=>setTimeout(d,1e3)),e.hierarchicalNodes&&e.hierarchicalNodes.length>0){const d=e.hierarchicalNodes[0].children.filter(l=>l.children&&Array.isArray(l.children)&&l.children.length>0),i=C({targetNodeId:u,nodes:[{name:"Content Container",supertags:[],children:d}]});console.log(`Chunked content into ${i.length} parts`);const g=[];for(let l=0;l<i.length;l++){const y=i[l];console.log(`Sending content chunk ${l+1}/${i.length} (${JSON.stringify(y).length} chars)`);try{const m=await f(y,t.apiKey);g.push(m),l<i.length-1&&await new Promise(S=>setTimeout(S,1500))}catch(m){throw console.error(`Error sending content chunk ${l+1}:`,m),m instanceof Error&&m.message.includes("429")?new Error(`Rate limit exceeded while sending chunk ${l+1}/${i.length}. Please wait a moment and try again.`):new Error(`Failed to send content chunk ${l+1}/${i.length}: ${m}`)}}return{success:!0,data:{mainNode:c,contentChunks:g.length,responses:[c,...g]}}}return{success:!0,data:{mainNode:c,contentChunks:0,responses:[c]}}}catch(t){throw console.error("Error saving to Tana:",t),t}}async function A(){return new Promise((e,t)=>{chrome.storage.sync.get(["apiKey","targetNodeId","supertagId","tanaFieldIds"],r=>{try{T(r),e(r)}catch(n){t(n)}})})}function T(e){if(!e.apiKey)throw new Error("API Token not configured. Please go to extension options and set up your configuration.");if(!e.supertagId)throw new Error("Supertag ID not configured. Please extract and save your Tana schema in options.");if(!e.targetNodeId)throw new Error("Target Node ID is required. Please go to options and specify a target node ID.");if(!e.tanaFieldIds)throw new Error("Field IDs not configured. Please extract and save your Tana schema in options.")}async function f(e,t,r=0){console.log(`Sending request to Tana API (attempt ${r+1})...`);try{const s=await fetch("https://europe-west1-tagr-prod.cloudfunctions.net/addToNodeV2",{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${t}`},body:JSON.stringify(e)});if(console.log("API response status:",s.status),!s.ok){const c=await s.text();if(console.error("API error response:",c),s.status===429&&r<3){const u=2e3*Math.pow(2,r);return console.log(`Rate limited. Retrying in ${u}ms...`),await new Promise(a=>setTimeout(a,u)),f(e,t,r+1)}throw new Error(`API error (${s.status}): ${c}`)}const h=await s.json();return console.log("API success response:",h),h}catch(s){if(r<3&&!(s instanceof Error&&s.message.includes("API error"))){const h=2e3*Math.pow(2,r);return console.log(`Network error. Retrying in ${h}ms...`),await new Promise(c=>setTimeout(c,h)),f(e,t,r+1)}throw s}}
//# sourceMappingURL=background.js.map
