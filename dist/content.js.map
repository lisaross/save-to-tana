{"version":3,"file":"content.js","sources":["../src/utils/extractContentForTana.ts","../src/content.ts"],"sourcesContent":["import type { TanaNode, TanaNodeChild, TanaNodeChildContent } from '../types/index';\nimport { Readability } from '@mozilla/readability';\nimport { sanitizeText } from './textUtils';\n\n/**\n * Extracts content from a DOM Document using structural sections as natural separators.\n * Does NOT use headings for organization - organizes by larger structural elements instead.\n * Creates single nodes for each major section, respecting Tana API constraints.\n * @param doc - The DOM Document to extract content from\n * @returns Array of TanaNode objects ready for the Tana input API\n */\nexport function extractContentForTana(doc: Document): TanaNode[] {\n  // Tana API constraints\n  const MAX_NODE_NAME_LENGTH = 800; // Increased for content with links\n  const MAX_NODE_CONTENT_LENGTH = 2000; // Increased for better content preservation\n  const MAX_SECTIONS = 50; // Limit sections to stay under 100 node limit (with children)\n  \n  // Use the correct Node/Element constructors for the environment\n  const NodeCtor = doc.defaultView?.Node;\n  const ElementCtor = doc.defaultView?.Element;\n\n  // Helper to get formatted text with inline formatting\n  function getFormattedText(node: any): string {\n    if (NodeCtor && node instanceof NodeCtor && node.nodeType === NodeCtor.TEXT_NODE) {\n      return node.textContent || '';\n    }\n    if (!(ElementCtor && node instanceof ElementCtor)) {\n      return '';\n    }\n    switch (node.tagName) {\n      case 'A': {\n        const href = (node as HTMLAnchorElement).href;\n        const text = Array.from(node.childNodes).map(getFormattedText).join('');\n        return `[${text}](${href})`;\n      }\n      case 'STRONG':\n      case 'B': {\n        const text = Array.from(node.childNodes).map(getFormattedText).join('');\n        return `**${text}**`;\n      }\n      case 'EM':\n      case 'I': {\n        const text = Array.from(node.childNodes).map(getFormattedText).join('');\n        return `*${text}*`;\n      }\n      default: {\n        return Array.from(node.childNodes).map(getFormattedText).join('');\n      }\n    }\n  }\n\n  // Helper to sanitize node names for Tana API (remove newlines, collapse whitespace, limit length)\n  function sanitizeNodeName(name: string, maxLength: number = MAX_NODE_NAME_LENGTH): string {\n    const sanitized = sanitizeText(name);\n    if (sanitized.length <= maxLength) {\n      return sanitized;\n    }\n    \n    // Check if the content contains URLs or markdown links - be more generous with length\n    const hasLinks = sanitized.includes('](') || sanitized.includes('http');\n    if (hasLinks) {\n      // For content with links, try to preserve the full link if possible\n      const linkMatch = sanitized.match(/\\[([^\\]]+)\\]\\(([^)]+)\\)/);\n      if (linkMatch && linkMatch[0].length < maxLength) {\n        // Try to include the full link and some surrounding context\n        const linkStart = sanitized.indexOf(linkMatch[0]);\n        const beforeLink = sanitized.substring(0, linkStart);\n        const afterLink = sanitized.substring(linkStart + linkMatch[0].length);\n        \n        const availableSpace = maxLength - linkMatch[0].length;\n        const beforeTruncated = beforeLink.length > availableSpace / 2 \n          ? beforeLink.substring(0, Math.floor(availableSpace / 2)) + '...'\n          : beforeLink;\n        const afterTruncated = afterLink.length > availableSpace / 2\n          ? '...' + afterLink.substring(afterLink.length - Math.floor(availableSpace / 2))\n          : afterLink;\n        \n        return (beforeTruncated + linkMatch[0] + afterTruncated).trim();\n      }\n    }\n    \n    // Try to truncate at sentence boundary first\n    const sentences = sanitized.match(/[^.!?]+[.!?]+/g);\n    if (sentences && sentences.length > 1) {\n      let truncated = '';\n      for (const sentence of sentences) {\n        if ((truncated + sentence).length <= maxLength) {\n          truncated += sentence;\n        } else {\n          break;\n        }\n      }\n      if (truncated.length > maxLength * 0.5) {\n        return truncated.trim();\n      }\n    }\n    \n    // Truncate at word boundary if possible\n    const truncated = sanitized.substring(0, maxLength);\n    const lastSpace = truncated.lastIndexOf(' ');\n    if (lastSpace > maxLength * 0.7) { // Only use word boundary if it's not too short\n      return truncated.substring(0, lastSpace) + '...';\n    }\n    \n    return truncated + '...';\n  }\n\n  // Helper to split long content into manageable chunks\n  function splitContentIntoChunks(content: string, maxLength: number = MAX_NODE_CONTENT_LENGTH): string[] {\n    if (content.length <= maxLength) {\n      return [content];\n    }\n    \n    const chunks: string[] = [];\n    const sentences = content.match(/[^.!?]+[.!?]+/g) || [content];\n    let currentChunk = '';\n    \n    for (const sentence of sentences) {\n      const trimmedSentence = sentence.trim();\n      if (!trimmedSentence) continue;\n      \n      if ((currentChunk + ' ' + trimmedSentence).length > maxLength) {\n        if (currentChunk) {\n          chunks.push(currentChunk.trim());\n          currentChunk = '';\n        }\n        \n        // If single sentence is too long, split it carefully to preserve links\n        if (trimmedSentence.length > maxLength) {\n          const linkMatches = Array.from(trimmedSentence.matchAll(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g));\n          if (linkMatches.length > 0) {\n            // Try to keep links intact when splitting\n            let remaining = trimmedSentence;\n            while (remaining.length > maxLength) {\n              let splitPoint = maxLength;\n              // Look for a safe split point that doesn't break links\n              for (const match of linkMatches) {\n                const linkStart = remaining.indexOf(match[0]);\n                const linkEnd = linkStart + match[0].length;\n                if (linkStart < maxLength && linkEnd > maxLength) {\n                  // Link would be split, move split point before the link\n                  splitPoint = Math.max(linkStart - 1, maxLength / 2);\n                  break;\n                }\n              }\n              const chunk = remaining.substring(0, splitPoint);\n              chunks.push(chunk + (splitPoint < remaining.length ? '...' : ''));\n              remaining = remaining.substring(splitPoint);\n            }\n            if (remaining.trim()) {\n              chunks.push(remaining.trim());\n            }\n          } else {\n            // No links, split normally\n            for (let i = 0; i < trimmedSentence.length; i += maxLength) {\n              const chunk = trimmedSentence.slice(i, i + maxLength);\n              chunks.push(chunk + (i + maxLength < trimmedSentence.length ? '...' : ''));\n            }\n          }\n        } else {\n          currentChunk = trimmedSentence;\n        }\n      } else {\n        currentChunk += (currentChunk ? ' ' : '') + trimmedSentence;\n      }\n    }\n    \n    if (currentChunk.trim()) {\n      chunks.push(currentChunk.trim());\n    }\n    \n    return chunks.length > 0 ? chunks : [content.substring(0, maxLength) + '...'];\n  }\n\n  // Helper to check if element should be excluded (navigation, sidebars, footers, etc.)\n  function shouldExcludeElement(element: Element): boolean {\n    const tagName = element.tagName.toLowerCase();\n    const className = element.className || '';\n    const id = element.id || '';\n    const role = element.getAttribute('role') || '';\n    \n    // Skip non-content elements\n    if (['script', 'style', 'noscript', 'head', 'meta', 'link'].includes(tagName)) {\n      return true;\n    }\n    \n    // Skip navigation elements\n    if (tagName === 'nav' || role === 'navigation') {\n      return true;\n    }\n    \n    // Skip elements with navigation-related classes/IDs\n    const navPatterns = [\n      'nav', 'navigation', 'menu', 'header', 'footer', 'sidebar', 'aside',\n      'breadcrumb', 'toolbar', 'topbar', 'bottombar', 'social', 'share',\n      'cookie', 'banner', 'popup', 'modal', 'overlay', 'fixed', 'sticky',\n      'advertisement', 'ads', 'promo'\n    ];\n    \n    const elementText = (className + ' ' + id).toLowerCase();\n    if (navPatterns.some(pattern => elementText.includes(pattern))) {\n      return true;\n    }\n    \n    // Skip elements that are positioned outside the main flow\n    const style = element.getAttribute('style') || '';\n    if (style.includes('position: fixed') || style.includes('position: absolute')) {\n      return true;\n    }\n    \n    // Skip hidden elements\n    if (style.includes('display: none') || style.includes('visibility: hidden')) {\n      return true;\n    }\n    \n    return false;\n  }\n\n  // Helper to check if element is a main structural section (NO HEADING LOGIC)\n  function isContentSection(element: Element): boolean {\n    const tagName = element.tagName.toLowerCase();\n    const className = element.className || '';\n    const id = element.id || '';\n    \n    // Primary structural elements that typically contain content\n    if (['section', 'article', 'main', 'div', 'p', 'ul', 'ol', 'blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tagName)) {\n      // For paragraphs, lists, blockquotes, and headings, they're always content sections\n      if (['p', 'ul', 'ol', 'blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tagName)) {\n        return true;\n      }\n      \n      // For structural elements, check if they have meaningful content indicators\n      const contentIndicators = [\n        'content', 'text', 'body', 'article', 'section', 'block', 'panel', \n        'card', 'item', 'feature', 'intro', 'description', 'summary'\n      ];\n      \n      const elementText = (className + ' ' + id).toLowerCase();\n      const hasContentClass = contentIndicators.some(indicator => \n        elementText.includes(indicator)\n      );\n      \n      // Also consider divs that are direct children of body or main containers\n      const isTopLevelDiv = tagName === 'div' && (\n        element.parentElement?.tagName.toLowerCase() === 'body' ||\n        element.parentElement?.tagName.toLowerCase() === 'main' ||\n        element.parentElement?.className.includes('container') ||\n        element.parentElement?.className.includes('wrapper') ||\n        element.parentElement?.className.includes('content')\n      );\n      \n      return hasContentClass || isTopLevelDiv || ['section', 'article', 'main'].includes(tagName);\n    }\n    \n    return false;\n  }\n\n  // Helper to extract clean content from a section (NO HEADING EXTRACTION)\n  function extractSectionContent(section: Element): string {\n    // Clone the section to avoid modifying the original\n    const sectionClone = section.cloneNode(true) as Element;\n    \n    // Remove navigation and excluded elements\n    const excludedElements = sectionClone.querySelectorAll('nav, .nav, .navigation, .menu, .breadcrumb, .social, .share, script, style');\n    for (const el of Array.from(excludedElements)) {\n      el.remove();\n    }\n    \n    // Get text content and clean it up\n    let text = '';\n    for (const child of Array.from(sectionClone.childNodes)) {\n      if (child.nodeType === (NodeCtor?.TEXT_NODE || 3)) {\n        text += child.textContent || '';\n      } else if (child.nodeType === (NodeCtor?.ELEMENT_NODE || 1)) {\n        const childEl = child as Element;\n        text += getFormattedText(childEl);\n      }\n    }\n    \n    return sanitizeText(text);\n  }\n\n  // Try to get main content area first\n  let main: HTMLElement | null = null;\n  \n  try {\n    // Look for main content area\n    main = doc.querySelector('main') || \n           doc.querySelector('[role=\"main\"]') || \n           doc.querySelector('.main-content') ||\n           doc.querySelector('#main-content') ||\n           doc.querySelector('.content') ||\n           doc.body;\n  } catch (e) {\n    main = doc.body;\n  }\n  \n  if (!main) return [];\n\n  // Find all content sections within the main area (NO HEADING-BASED ORGANIZATION)\n  const contentSections: Array<{ element: Element; content: string }> = [];\n  const processedElements = new Set<Element>();\n\n  function findContentSections(container: Element) {\n    for (const child of Array.from(container.children)) {\n      if (processedElements.has(child) || shouldExcludeElement(child)) {\n        continue;\n      }\n\n      if (isContentSection(child)) {\n        const content = extractSectionContent(child);\n        \n        // Only include sections with meaningful content\n        if (content.length > 10 && content.length < 8000) {\n          contentSections.push({\n            element: child,\n            content\n          });\n          processedElements.add(child);\n          \n          // Stop if we have enough sections\n          if (contentSections.length >= MAX_SECTIONS) {\n            return;\n          }\n          continue;\n        }\n      }\n      \n      // Recursively check children if this wasn't processed as a section\n      if (!processedElements.has(child) && contentSections.length < MAX_SECTIONS) {\n        findContentSections(child);\n      }\n    }\n  }\n\n  findContentSections(main);\n\n  // If we didn't find enough sections, be more liberal in what we consider content\n  if (contentSections.length < 3) {\n    // Look for any elements with substantial text content\n    const allElements = main.querySelectorAll('div, section, article, p, ul, ol, blockquote');\n    for (const element of Array.from(allElements)) {\n      if (processedElements.has(element) || shouldExcludeElement(element)) {\n        continue;\n      }\n      \n      const content = extractSectionContent(element);\n      if (content.length > 15 && content.length < 5000) {\n        contentSections.push({\n          element,\n          content\n        });\n        processedElements.add(element);\n        \n        if (contentSections.length >= MAX_SECTIONS) break;\n      }\n    }\n  }\n\n  // Create nodes from content sections (NO HEADING-BASED NAMES)\n  const children: TanaNodeChildContent[] = [];\n  \n  for (const section of contentSections.slice(0, MAX_SECTIONS)) {\n    // Use the first part of content as the node name (no heading extraction)\n    const firstSentence = section.content.split(/[.!?]/)[0];\n    const nodeName = sanitizeNodeName(firstSentence, 200); // Reasonable length for auto-generated names\n    \n    // Split content into chunks if it's too long\n    const contentChunks = splitContentIntoChunks(section.content);\n    \n    if (contentChunks.length === 1) {\n      // Single chunk - use the content directly as the node name\n      children.push({\n        name: sanitizeNodeName(contentChunks[0])\n      });\n    } else {\n      // Multiple content chunks - create child nodes for each\n      const contentChildren = contentChunks.map((chunk) => ({\n        name: sanitizeText(chunk)\n      }));\n      \n      children.push({\n        name: nodeName,\n        children: contentChildren\n      });\n    }\n  }\n\n  // If no sections found, create a single node with page content\n  if (children.length === 0) {\n    const pageContent = extractSectionContent(main);\n    if (pageContent.length > 15) {\n      const contentChunks = splitContentIntoChunks(pageContent);\n      \n      if (contentChunks.length === 1) {\n        children.push({\n          name: sanitizeNodeName(contentChunks[0])\n        });\n      } else {\n        const pageName = sanitizeNodeName(doc.title || 'Page Content');\n        children.push({\n          name: pageName,\n          children: contentChunks.map(chunk => ({ name: sanitizeText(chunk) }))\n        });\n      }\n    }\n  }\n\n  const rootNode: TanaNode = {\n    name: sanitizeNodeName(doc.title || 'Page Content'),\n    supertags: [],\n    children: children as (TanaNodeChild | TanaNodeChildContent)[],\n  };\n\n  return [rootNode];\n} ","/**\n * Content script interfaces\n */\nimport { extractContentForTana } from './utils/extractContentForTana';\nimport type { TanaNode } from './types/index';\n\ninterface ExtractOptions {\n  includeContent: boolean;\n  includeTitle: boolean;\n}\n\ninterface ExtractRequest {\n  action: 'extractContent' | 'ping';\n  options?: ExtractOptions;\n}\n\ninterface PageData {\n  url: string;\n  title: string;\n  author: string;\n  description: string;\n  content: string;\n  hierarchicalNodes?: TanaNode[];\n  error?: boolean;\n  message?: string;\n}\n\n/**\n * Content script - extracts content from the current page\n */\n\n// Listen for messages from the popup\nchrome.runtime.onMessage.addListener((\n  request: ExtractRequest,\n  sender: chrome.runtime.MessageSender,\n  sendResponse: (response: PageData | { pong: boolean }) => void\n) => {\n  // Handle ping requests to check if content script is loaded\n  if (request.action === 'ping') {\n    sendResponse({ pong: true });\n    return true;\n  }\n  \n  if (request.action === 'extractContent') {\n    const options = request.options || { includeContent: true, includeTitle: true };\n    \n    try {\n      // Extract page information\n      const pageData: PageData = {\n        url: window.location.href,\n        title: document.title,\n        author: extractAuthor(),\n        description: extractDescription(),\n        content: '' // Keeping this for now but not populating - using hierarchical content instead\n      };\n      \n      // Extract hierarchical content structure if requested\n      if (options.includeContent) {\n        try {\n          pageData.hierarchicalNodes = extractContentForTana(document);\n        } catch (error) {\n          console.warn('Could not extract hierarchical content:', error);\n        }\n      }\n      \n      // If title is not requested, use URL as title\n      if (!options.includeTitle || !pageData.title) {\n        pageData.title = pageData.url;\n      }\n      \n      // Pre-sanitize title to avoid API errors\n      if (pageData.title) {\n        pageData.title = pageData.title.replace(/\\r?\\n|\\r/g, ' ').trim();\n      }\n      \n      sendResponse(pageData);\n    } catch (error) {\n      console.error('Content extraction error:', error);\n      sendResponse({\n        url: window.location.href,\n        title: document.title,\n        author: '',\n        description: '',\n        content: '',\n        error: true,\n        message: error instanceof Error ? error.message : 'Unknown error occurred during content extraction'\n      });\n    }\n  }\n  \n  // Must return true for asynchronous response\n  return true;\n});\n\n/**\n * Extract author from meta tags and common page elements\n * @returns The extracted author or empty string if not found\n */\nfunction extractAuthor(): string {\n  // Try various meta tags that might contain author information\n  const authorSelectors = [\n    'meta[name=\"author\"]',\n    'meta[property=\"article:author\"]',\n    'meta[name=\"twitter:creator\"]',\n    'meta[property=\"og:site_name\"]'\n  ];\n  \n  for (const selector of authorSelectors) {\n    const metaTag = document.querySelector(selector);\n    if (metaTag && metaTag.getAttribute('content')) {\n      return metaTag.getAttribute('content') || '';\n    }\n  }\n  \n  // Try schema.org markup\n  const schemaSelectors = [\n    '[itemtype*=\"schema.org/Person\"] [itemprop=\"name\"]',\n    '[itemtype*=\"schema.org/Organization\"] [itemprop=\"name\"]'\n  ];\n  \n  for (const selector of schemaSelectors) {\n    const element = document.querySelector(selector);\n    if (element && element.textContent) {\n      return element.textContent.trim();\n    }\n  }\n  \n  // Try byline classes commonly used\n  const bylineSelectors = ['.byline', '.author', '.article-author'];\n  \n  for (const selector of bylineSelectors) {\n    const element = document.querySelector(selector);\n    if (element && element.textContent) {\n      return element.textContent.trim();\n    }\n  }\n  \n  return '';\n}\n\n/**\n * Extract description from meta tags\n * @returns The extracted description or empty string if not found\n */\nfunction extractDescription(): string {\n  // Try various meta tags that might contain description\n  const descriptionSelectors = [\n    'meta[name=\"description\"]',\n    'meta[property=\"og:description\"]',\n    'meta[name=\"twitter:description\"]'\n  ];\n  \n  for (const selector of descriptionSelectors) {\n    const metaTag = document.querySelector(selector);\n    if (metaTag && metaTag.getAttribute('content')) {\n      return metaTag.getAttribute('content') || '';\n    }\n  }\n  \n  return '';\n}\n"],"names":["extractContentForTana","doc","NodeCtor","ElementCtor","getFormattedText","node","href","sanitizeNodeName","name","maxLength","sanitized","sanitizeText","linkMatch","linkStart","beforeLink","afterLink","availableSpace","beforeTruncated","afterTruncated","sentences","truncated","sentence","lastSpace","splitContentIntoChunks","content","chunks","currentChunk","trimmedSentence","linkMatches","remaining","splitPoint","match","linkEnd","chunk","shouldExcludeElement","element","tagName","className","id","role","navPatterns","elementText","pattern","style","isContentSection","contentIndicators","hasContentClass","indicator","isTopLevelDiv","extractSectionContent","section","sectionClone","excludedElements","el","text","child","main","contentSections","processedElements","findContentSections","container","allElements","children","firstSentence","nodeName","contentChunks","contentChildren","pageContent","pageName","request","sender","sendResponse","options","pageData","extractAuthor","extractDescription","error","authorSelectors","selector","metaTag","schemaSelectors","bylineSelectors","descriptionSelectors"],"mappings":"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"}