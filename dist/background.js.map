{"version":3,"file":"background.js","sources":["../src/tanaPayloadBuilder.ts","../src/utils/payloadChunker.ts","../src/background.ts"],"sourcesContent":["import { \n  SaveData, \n  TanaFieldIds, \n  TanaPayload, \n  TanaNode,\n  TanaNodeChildContent\n} from './types/index';\nimport { sanitizeText, splitIntoChunks } from './utils/textUtils';\n\n/**\n * Build a Tana API payload using the extracted schema and content data.\n * @param data - The content data (url, title, author, description, content)\n * @param targetNodeId - The Tana node to save under\n * @param supertagId - The supertag ID for the node\n * @param fieldIds - Mapping of field names to attribute IDs\n * @returns Tana API payload\n */\nexport function buildTanaPayload(\n  data: SaveData, \n  targetNodeId: string, \n  supertagId: string, \n  fieldIds: TanaFieldIds\n): TanaPayload {\n  // Validate required parameters\n  if (!data) {\n    throw new Error('SaveData is required');\n  }\n  if (!targetNodeId || !targetNodeId.trim()) {\n    throw new Error('Valid targetNodeId is required');\n  }\n  if (!supertagId || !supertagId.trim()) {\n    throw new Error('Valid supertagId is required');\n  }\n  if (!fieldIds) {\n    throw new Error('TanaFieldIds is required');\n  }\n\n  // Build the main node\n  const mainNode: TanaNode = {\n    name: sanitizeText(data.title || data.url),\n    supertags: [{ id: supertagId }],\n    children: []\n  };\n\n  // Add URL field\n  if (data.url && fieldIds.URL) {\n    mainNode.children.push({\n      type: 'field',\n      attributeId: fieldIds.URL,\n      children: [{ dataType: 'url', name: data.url }]\n    });\n  }\n  \n  // Add Author field\n  if (data.author && fieldIds.Author) {\n    mainNode.children.push({\n      type: 'field',\n      attributeId: fieldIds.Author,\n      children: [{ name: sanitizeText(data.author) }]\n    });\n  }\n  \n  // Add Description field\n  if (data.description && fieldIds.Description) {\n    mainNode.children.push({\n      type: 'field',\n      attributeId: fieldIds.Description,\n      children: [{ name: sanitizeText(data.description) }]\n    });\n  }\n  \n  // Add Content field (chunked if needed) - COMMENTED OUT - using hierarchical content instead\n  // if (data.content && fieldIds.Content) {\n  //   const sanitizedContent = sanitizeText(data.content);\n  //   const maxContentLength = 4000;\n  //   let contentChunks: TanaNodeChildContent[] = [];\n  //   \n  //   if (sanitizedContent.length > maxContentLength) {\n  //     contentChunks = splitIntoChunks(sanitizedContent, maxContentLength)\n  //       .map(chunk => ({ name: chunk }));\n  //   } else {\n  //     contentChunks = [{ name: sanitizedContent }];\n  //   }\n  //   \n  //   mainNode.children.push({\n  //     type: 'field',\n  //     attributeId: fieldIds.Content,\n  //     children: contentChunks\n  //   });\n  // }\n\n  return {\n    targetNodeId,\n    nodes: [mainNode]\n  };\n}\n","import { TanaPayload, TanaNode, TanaNodeChild, TanaNodeChildContent } from '../types/index';\n\n/**\n * Configuration for payload chunking\n */\ninterface ChunkConfig {\n  maxPayloadSize: number;  // Maximum JSON string size (Tana limit: 5000 chars)\n  maxNodesPerChunk: number; // Maximum nodes per chunk (Tana limit: 100 nodes)\n  maxChildrenPerNode: number; // Maximum children per node to prevent deep nesting issues\n}\n\n/**\n * Default chunking configuration based on Tana API limits\n */\nconst DEFAULT_CHUNK_CONFIG: ChunkConfig = {\n  maxPayloadSize: 4500, // Leave some buffer under the 5000 char limit\n  maxNodesPerChunk: 90,  // Leave some buffer under the 100 node limit  \n  maxChildrenPerNode: 50 // Reasonable limit to prevent overly deep structures\n};\n\n/**\n * Calculate the approximate size of a JSON payload in characters\n */\nfunction calculatePayloadSize(payload: TanaPayload): number {\n  return JSON.stringify(payload).length;\n}\n\n/**\n * Count total nodes in a payload (including nested children)\n */\nfunction countNodesInPayload(payload: TanaPayload): number {\n  function countNodesRecursive(node: TanaNode | TanaNodeChild | TanaNodeChildContent): number {\n    let count = 1; // Count the node itself\n    \n    if ('children' in node && Array.isArray(node.children)) {\n      for (const child of node.children) {\n        count += countNodesRecursive(child);\n      }\n    }\n    \n    return count;\n  }\n  \n  return payload.nodes.reduce((total, node) => total + countNodesRecursive(node), 0);\n}\n\n/**\n * Split hierarchical content into smaller chunks while preserving structure\n */\nfunction chunkHierarchicalContent(\n  content: (TanaNodeChild | TanaNodeChildContent)[],\n  config: ChunkConfig\n): (TanaNodeChild | TanaNodeChildContent)[][] {\n  const chunks: (TanaNodeChild | TanaNodeChildContent)[][] = [];\n  let currentChunk: (TanaNodeChild | TanaNodeChildContent)[] = [];\n  \n  for (const item of content) {\n    // Create a test payload to see if adding this item would exceed size limits\n    const testPayload = {\n      targetNodeId: 'test',\n      nodes: [{\n        name: 'Test',\n        supertags: [],\n        children: [...currentChunk, item]\n      }]\n    };\n    \n    const testSize = JSON.stringify(testPayload).length;\n    const wouldExceedSize = testSize > config.maxPayloadSize;\n    const wouldExceedChildrenLimit = currentChunk.length >= config.maxChildrenPerNode;\n    \n    // If adding this item would exceed limits, start a new chunk\n    if ((wouldExceedSize || wouldExceedChildrenLimit) && currentChunk.length > 0) {\n      chunks.push([...currentChunk]);\n      currentChunk = [];\n    }\n    \n    // If item has children and is itself too large, split its children\n    if ('children' in item && Array.isArray(item.children) && item.children.length > 0) {\n      const itemSize = JSON.stringify(item).length;\n      \n      if (itemSize > config.maxPayloadSize * 0.8) { // Use 80% of limit for individual items\n        const childChunks = chunkHierarchicalContent(item.children, config);\n        \n        // Create multiple items with chunked children - no part numbering for hierarchy\n        for (let i = 0; i < childChunks.length; i++) {\n          const chunkItem = { \n            ...item, \n            name: 'name' in item ? item.name : 'Content',\n            children: childChunks[i] \n          };\n          \n          // Check if this chunk item would fit in current chunk\n          const testChunkPayload = {\n            targetNodeId: 'test',\n            nodes: [{\n              name: 'Test',\n              supertags: [],\n              children: [...currentChunk, chunkItem]\n            }]\n          };\n          \n          if (JSON.stringify(testChunkPayload).length > config.maxPayloadSize && currentChunk.length > 0) {\n            chunks.push([...currentChunk]);\n            currentChunk = [];\n          }\n          \n          currentChunk.push(chunkItem);\n        }\n      } else {\n        currentChunk.push(item);\n      }\n    } else {\n      currentChunk.push(item);\n    }\n  }\n  \n  if (currentChunk.length > 0) {\n    chunks.push(currentChunk);\n  }\n  \n  return chunks.length > 0 ? chunks : [[]];\n}\n\n/**\n * Create multiple payloads from a single large payload by chunking content\n */\nexport function chunkTanaPayload(\n  originalPayload: TanaPayload,\n  config: ChunkConfig = DEFAULT_CHUNK_CONFIG\n): TanaPayload[] {\n  // If payload is small enough, return as-is\n  const originalSize = calculatePayloadSize(originalPayload);\n  const originalNodeCount = countNodesInPayload(originalPayload);\n  \n  if (originalSize <= config.maxPayloadSize && originalNodeCount <= config.maxNodesPerChunk) {\n    return [originalPayload];\n  }\n  \n  const chunks: TanaPayload[] = [];\n  \n  for (const originalNode of originalPayload.nodes) {\n    if (!originalNode.children || originalNode.children.length === 0) {\n      // Node has no children, create a simple payload\n      const simplePayload: TanaPayload = {\n        targetNodeId: originalPayload.targetNodeId,\n        nodes: [{ ...originalNode }]\n      };\n      \n      chunks.push(simplePayload);\n      continue;\n    }\n    \n    // Separate field nodes from content nodes\n    const fieldNodes: (TanaNodeChild | TanaNodeChildContent)[] = [];\n    const contentNodes: (TanaNodeChild | TanaNodeChildContent)[] = [];\n    \n    for (const child of originalNode.children) {\n      if ('type' in child && child.type === 'field') {\n        fieldNodes.push(child);\n      } else {\n        contentNodes.push(child);\n      }\n    }\n    \n    // If there are no content nodes, create a simple payload with just fields\n    if (contentNodes.length === 0) {\n      const simplePayload: TanaPayload = {\n        targetNodeId: originalPayload.targetNodeId,\n        nodes: [{ ...originalNode, children: fieldNodes }]\n      };\n      \n      chunks.push(simplePayload);\n      continue;\n    }\n    \n    // Chunk the content nodes\n    const contentChunks = chunkHierarchicalContent(contentNodes, config);\n    \n    for (let i = 0; i < contentChunks.length; i++) {\n      // Don't add part numbers to node names when chunking - hierarchy handles organization\n      const chunkNode: TanaNode = {\n        ...originalNode,\n        name: originalNode.name,\n        children: contentChunks[i]\n      };\n      \n      const chunkPayload: TanaPayload = {\n        targetNodeId: originalPayload.targetNodeId,\n        nodes: [chunkNode]\n      };\n      \n      // Verify chunk is within limits\n      const chunkSize = calculatePayloadSize(chunkPayload);\n      const chunkNodeCount = countNodesInPayload(chunkPayload);\n      \n      if (chunkSize > config.maxPayloadSize || chunkNodeCount > config.maxNodesPerChunk) {\n        console.warn(`Chunk ${i + 1} still exceeds limits: ${chunkSize} chars, ${chunkNodeCount} nodes`);\n        // TODO: Could implement more aggressive chunking here if needed\n      }\n      \n      chunks.push(chunkPayload);\n    }\n  }\n  \n  return chunks.length > 0 ? chunks : [originalPayload];\n}\n\n/**\n * Information about the chunking result\n */\nexport interface ChunkingInfo {\n  totalChunks: number;\n  originalSize: number;\n  originalNodeCount: number;\n  averageChunkSize: number;\n  averageChunkNodeCount: number;\n  chunksExceedingLimits: number;\n}\n\n/**\n * Get information about the chunking process\n */\nexport function getChunkingInfo(\n  originalPayload: TanaPayload,\n  chunks: TanaPayload[],\n  config: ChunkConfig = DEFAULT_CHUNK_CONFIG\n): ChunkingInfo {\n  const originalSize = calculatePayloadSize(originalPayload);\n  const originalNodeCount = countNodesInPayload(originalPayload);\n  \n  const chunkSizes = chunks.map(calculatePayloadSize);\n  const chunkNodeCounts = chunks.map(countNodesInPayload);\n  \n  const averageChunkSize = chunkSizes.reduce((sum, size) => sum + size, 0) / chunks.length;\n  const averageChunkNodeCount = chunkNodeCounts.reduce((sum, count) => sum + count, 0) / chunks.length;\n  \n  const chunksExceedingLimits = chunks.filter((chunk, i) => \n    chunkSizes[i] > config.maxPayloadSize || chunkNodeCounts[i] > config.maxNodesPerChunk\n  ).length;\n  \n  return {\n    totalChunks: chunks.length,\n    originalSize,\n    originalNodeCount,\n    averageChunkSize: Math.round(averageChunkSize),\n    averageChunkNodeCount: Math.round(averageChunkNodeCount),\n    chunksExceedingLimits\n  };\n} ","import { \n  SaveData, \n  SaveResponse, \n  TanaConfig, \n  SaveToTanaRequest,\n  TanaPayload,\n  TanaNodeChild,\n  TanaNodeChildContent\n} from 'types';\nimport { buildTanaPayload } from './tanaPayloadBuilder';\nimport { chunkTanaPayload, getChunkingInfo } from './utils/payloadChunker';\n\n/**\n * Background script - handles API communication with Tana\n */\n\n// No context menu needed since we removed the extractor\nchrome.runtime.onInstalled.addListener(() => {\n  console.log('Save to Tana extension installed');\n});\n\n// Handle messages from popup and content scripts\nchrome.runtime.onMessage.addListener((\n  request: SaveToTanaRequest, \n  sender: chrome.runtime.MessageSender, \n  sendResponse: (response: SaveResponse) => void\n) => {\n  if (request.action === 'saveToTana') {\n    saveToTana(request.data)\n      .then(result => {\n        sendResponse(result);\n      })\n      .catch(error => {\n        sendResponse({\n          success: false,\n          error: error instanceof Error ? error.message : 'Unknown error occurred'\n        });\n      });\n    \n    // Return true to indicate we will send a response asynchronously\n    return true;\n  }\n  return false;\n});\n\n/**\n * Function to save data to Tana\n * @param data - The data to save to Tana\n * @returns Promise resolving to a SaveResponse\n */\nasync function saveToTana(data: SaveData): Promise<SaveResponse> {\n  try {\n    console.log('Starting saveToTana with data:', data);\n    \n    // Get API key, target node ID, and schema info from storage\n    const result = await getStorageConfig();\n    \n    console.log('Retrieved configuration from storage:', result);\n    validateConfig(result);\n    \n    const targetNodeId = result.targetNodeId;\n    console.log('Using target node ID:', targetNodeId);\n    \n    // Build the payload using the schema\n    const tanaPayload = buildTanaPayload(\n      data, \n      targetNodeId, \n      result.supertagId, \n      result.tanaFieldIds\n    );\n    console.log('Formatted Tana payload:', tanaPayload);\n    \n    // Add hierarchical content nodes if available\n    if (data.hierarchicalNodes && data.hierarchicalNodes.length > 0 && tanaPayload.nodes.length > 0) {\n      // Include all content nodes - both hierarchical and flat\n      const contentNodes = data.hierarchicalNodes[0].children || [];\n      tanaPayload.nodes[0].children.push(...contentNodes);\n      console.log('Added content nodes:', contentNodes.length);\n    }\n    \n    // Check if we need to chunk the payload\n    const payloadSize = JSON.stringify(tanaPayload).length;\n    const needsChunking = payloadSize > 4500; // Conservative limit\n    \n    if (!needsChunking) {\n      // Small payload - send as-is\n      console.log(`Payload size: ${payloadSize} chars - sending as single request`);\n      const responseData = await sendToTanaApi(tanaPayload, result.apiKey);\n      \n      return {\n        success: true,\n        data: responseData\n      };\n    }\n    \n    // Large payload - needs chunking with hierarchical approach\n    console.log(`Large content detected (${payloadSize} chars). Using hierarchical chunking strategy.`);\n    \n    // First, create the main node with metadata only\n    const mainNodePayload = buildTanaPayload(\n      data, \n      targetNodeId, \n      result.supertagId, \n      result.tanaFieldIds\n    );\n    \n    console.log('Sending main node with metadata...');\n    const mainNodeResponse = await sendToTanaApi(mainNodePayload, result.apiKey);\n    \n    // Extract the created node ID from the response\n    const createdNodeId = mainNodeResponse.children?.[0]?.nodeId;\n    if (!createdNodeId) {\n      throw new Error('Could not get node ID from main node creation response');\n    }\n    \n    console.log(`Main node created with ID: ${createdNodeId}`);\n    \n    // Rate limiting: wait 1 second after creating main node before sending content chunks\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Now chunk the hierarchical content and add as children to the main node\n    if (data.hierarchicalNodes && data.hierarchicalNodes.length > 0) {\n      const contentNodes = data.hierarchicalNodes[0].children || [];\n      \n      // Create a single payload with just the content (no wrapper node) and chunk it\n      const contentPayload = {\n        targetNodeId: createdNodeId,\n        nodes: contentNodes.map((node: any) => ({\n          name: ('name' in node ? node.name : 'Content') || 'Content',\n          supertags: [] as { id: string }[],\n          children: (node.children || []) as (TanaNodeChild | TanaNodeChildContent)[]\n        }))\n      };\n      \n      // Chunk the content payload\n      const payloadChunks = chunkTanaPayload(contentPayload);\n      \n      console.log(`Chunked content into ${payloadChunks.length} parts`);\n      \n      // Send content chunks as children of the main node\n      const contentResponses = [];\n      for (let i = 0; i < payloadChunks.length; i++) {\n        const chunk = payloadChunks[i];\n        console.log(`Sending content chunk ${i + 1}/${payloadChunks.length} (${JSON.stringify(chunk).length} chars)`);\n        \n        try {\n          const chunkResponse = await sendToTanaApi(chunk, result.apiKey);\n          contentResponses.push(chunkResponse);\n          \n          // Rate limiting: wait 1.5 seconds between chunks to be extra safe\n          if (i < payloadChunks.length - 1) {\n            await new Promise(resolve => setTimeout(resolve, 1500));\n          }\n        } catch (error) {\n          console.error(`Error sending content chunk ${i + 1}:`, error);\n          \n          // If it's a rate limit error, provide a helpful message\n          if (error instanceof Error && error.message.includes('429')) {\n            throw new Error(`Rate limit exceeded while sending chunk ${i + 1}/${payloadChunks.length}. Please wait a moment and try again.`);\n          }\n          \n          throw new Error(`Failed to send content chunk ${i + 1}/${payloadChunks.length}: ${error}`);\n        }\n      }\n      \n      const responseData = {\n        mainNode: mainNodeResponse,\n        contentChunks: contentResponses.length,\n        responses: [mainNodeResponse, ...contentResponses]\n      };\n      \n      return {\n        success: true,\n        data: responseData\n      };\n    }\n    \n    // If no hierarchical content, just return the main node response\n    const responseData = {\n      mainNode: mainNodeResponse,\n      contentChunks: 0,\n      responses: [mainNodeResponse]\n    };\n    \n    return {\n      success: true,\n      data: responseData\n    };\n  } catch (error) {\n    console.error('Error saving to Tana:', error);\n    throw error;\n  }\n}\n\n/**\n * Get configuration from Chrome storage\n * @returns Promise resolving to TanaConfig\n */\nasync function getStorageConfig(): Promise<TanaConfig> {\n  return new Promise((resolve, reject) => {\n    chrome.storage.sync.get(\n      ['apiKey', 'targetNodeId', 'supertagId', 'tanaFieldIds'], \n      (result) => {\n        try {\n          validateConfig(result);\n          resolve(result as TanaConfig);\n        } catch (error) {\n          reject(error);\n        }\n      }\n    );\n  });\n}\n\n/**\n * Validate the configuration\n * @param config - The configuration to validate\n * @throws Error if configuration is invalid\n */\nfunction validateConfig(config: Partial<TanaConfig>): asserts config is TanaConfig {\n  if (!config.apiKey) {\n    throw new Error('API Token not configured. Please go to extension options and set up your configuration.');\n  }\n  \n  if (!config.supertagId) {\n    throw new Error('Supertag ID not configured. Please extract and save your Tana schema in options.');\n  }\n  \n  if (!config.targetNodeId) {\n    throw new Error('Target Node ID is required. Please go to options and specify a target node ID.');\n  }\n  \n  if (!config.tanaFieldIds) {\n    throw new Error('Field IDs not configured. Please extract and save your Tana schema in options.');\n  }\n}\n\n/**\n * Send payload to Tana API with retry logic for rate limiting\n * @param payload - The payload to send\n * @param apiKey - The API key for authentication\n * @param retryCount - Current retry attempt (for internal use)\n * @returns Promise resolving to the API response data\n */\nasync function sendToTanaApi(payload: TanaPayload, apiKey: string, retryCount = 0): Promise<any> {\n  const maxRetries = 3;\n  const baseDelay = 2000; // 2 seconds base delay\n  \n  console.log(`Sending request to Tana API (attempt ${retryCount + 1})...`);\n  \n  try {\n    const response = await fetch('https://europe-west1-tagr-prod.cloudfunctions.net/addToNodeV2', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`\n      },\n      body: JSON.stringify(payload)\n    });\n    \n    console.log('API response status:', response.status);\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('API error response:', errorText);\n      \n      // If it's a rate limit error and we haven't exceeded max retries, retry with exponential backoff\n      if (response.status === 429 && retryCount < maxRetries) {\n        const delay = baseDelay * Math.pow(2, retryCount); // Exponential backoff: 2s, 4s, 8s\n        console.log(`Rate limited. Retrying in ${delay}ms...`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return sendToTanaApi(payload, apiKey, retryCount + 1);\n      }\n      \n      throw new Error(`API error (${response.status}): ${errorText}`);\n    }\n    \n    const responseData = await response.json();\n    console.log('API success response:', responseData);\n    return responseData;\n  } catch (error) {\n    // If it's a network error and we haven't exceeded max retries, retry\n    if (retryCount < maxRetries && !(error instanceof Error && error.message.includes('API error'))) {\n      const delay = baseDelay * Math.pow(2, retryCount);\n      console.log(`Network error. Retrying in ${delay}ms...`);\n      await new Promise(resolve => setTimeout(resolve, delay));\n      return sendToTanaApi(payload, apiKey, retryCount + 1);\n    }\n    \n    throw error;\n  }\n}\n"],"names":["buildTanaPayload","data","targetNodeId","supertagId","fieldIds","mainNode","sanitizeText","DEFAULT_CHUNK_CONFIG","calculatePayloadSize","payload","countNodesInPayload","countNodesRecursive","node","count","child","total","chunkHierarchicalContent","content","config","chunks","currentChunk","item","testPayload","wouldExceedSize","wouldExceedChildrenLimit","childChunks","i","chunkItem","testChunkPayload","chunkTanaPayload","originalPayload","originalSize","originalNodeCount","originalNode","simplePayload","fieldNodes","contentNodes","contentChunks","chunkNode","chunkPayload","chunkSize","chunkNodeCount","request","sender","sendResponse","saveToTana","result","error","getStorageConfig","validateConfig","tanaPayload","payloadSize","sendToTanaApi","mainNodePayload","mainNodeResponse","createdNodeId","resolve","contentPayload","payloadChunks","contentResponses","chunk","chunkResponse","reject","apiKey","retryCount","response","errorText","delay","responseData"],"mappings":"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"}