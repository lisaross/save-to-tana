{"version":3,"file":"background.js","sources":["../src/utils/textUtils.ts","../src/tanaPayloadBuilder.ts","../src/background.ts"],"sourcesContent":["/**\n * Utility functions for text processing\n */\n\n/**\n * Sanitizes text for Tana API by removing newlines and extra spaces\n * @param text - The text to sanitize\n * @returns Sanitized text\n */\nexport function sanitizeText(text: string | undefined): string {\n  if (!text) return '';\n  \n  return text\n    .replace(/\\r?\\n|\\r/g, ' ')  // Replace newlines with spaces\n    .replace(/\\s+/g, ' ')       // Replace multiple spaces with a single space\n    .trim();\n}\n\n/**\n * Splits content into chunks of specified maximum size\n * @param content - The content to split\n * @param maxSize - Maximum size of each chunk\n * @returns Array of content chunks\n */\nexport function splitIntoChunks(content: string, maxSize: number): string[] {\n  const paragraphs = content.split(/\\n\\n+/);\n  const chunks: string[] = [];\n  let currentChunk = '';\n  \n  for (const paragraph of paragraphs) {\n    if ((currentChunk + paragraph).length > maxSize) {\n      if (currentChunk) {\n        chunks.push(currentChunk);\n        currentChunk = '';\n      }\n      \n      if (paragraph.length > maxSize) {\n        const sentences = paragraph.match(/[^.!?]+[.!?]+/g) || [paragraph];\n        \n        for (const sentence of sentences) {\n          if (sentence.length > maxSize) {\n            for (let i = 0; i < sentence.length; i += maxSize) {\n              chunks.push(sentence.slice(i, i + maxSize));\n            }\n          } else {\n            if ((currentChunk + sentence).length > maxSize) {\n              chunks.push(currentChunk);\n              currentChunk = sentence;\n            } else {\n              currentChunk += sentence;\n            }\n          }\n        }\n      } else {\n        currentChunk = paragraph;\n      }\n    } else {\n      currentChunk += (currentChunk ? '\\n\\n' : '') + paragraph;\n    }\n  }\n  \n  if (currentChunk) {\n    chunks.push(currentChunk);\n  }\n  \n  return chunks;\n}\n","import { \n  SaveData, \n  TanaFieldIds, \n  TanaPayload, \n  TanaNode,\n  TanaNodeChildContent\n} from './types/index';\nimport { sanitizeText, splitIntoChunks } from './utils/textUtils';\n\n/**\n * Build a Tana API payload using the extracted schema and content data.\n * @param data - The content data (url, title, author, description, content)\n * @param targetNodeId - The Tana node to save under\n * @param supertagId - The supertag ID for the node\n * @param fieldIds - Mapping of field names to attribute IDs\n * @returns Tana API payload\n */\nexport function buildTanaPayload(\n  data: SaveData, \n  targetNodeId: string, \n  supertagId: string, \n  fieldIds: TanaFieldIds\n): TanaPayload {\n  // Validate required parameters\n  if (!data) {\n    throw new Error('SaveData is required');\n  }\n  if (!targetNodeId || !targetNodeId.trim()) {\n    throw new Error('Valid targetNodeId is required');\n  }\n  if (!supertagId || !supertagId.trim()) {\n    throw new Error('Valid supertagId is required');\n  }\n  if (!fieldIds) {\n    throw new Error('TanaFieldIds is required');\n  }\n\n  // Build the main node\n  const mainNode: TanaNode = {\n    name: sanitizeText(data.title || data.url),\n    supertags: [{ id: supertagId }],\n    children: []\n  };\n\n  // Add URL field\n  if (data.url && fieldIds.URL) {\n    mainNode.children.push({\n      type: 'field',\n      attributeId: fieldIds.URL,\n      children: [{ dataType: 'url', name: data.url }]\n    });\n  }\n  \n  // Add Author field\n  if (data.author && fieldIds.Author) {\n    mainNode.children.push({\n      type: 'field',\n      attributeId: fieldIds.Author,\n      children: [{ name: sanitizeText(data.author) }]\n    });\n  }\n  \n  // Add Description field\n  if (data.description && fieldIds.Description) {\n    mainNode.children.push({\n      type: 'field',\n      attributeId: fieldIds.Description,\n      children: [{ name: sanitizeText(data.description) }]\n    });\n  }\n  \n  // Add user notes as a direct child node (appears in body)\n  if (data.notes && data.notes.trim()) {\n    mainNode.children.push({\n      name: sanitizeText(data.notes)\n    });\n  }\n  \n  // Add Content field (chunked if needed)\n  if (data.content && fieldIds.Content) {\n    const sanitizedContent = sanitizeText(data.content);\n    const maxContentLength = 4000;\n    let contentChunks: TanaNodeChildContent[] = [];\n    \n    if (sanitizedContent.length > maxContentLength) {\n      contentChunks = splitIntoChunks(sanitizedContent, maxContentLength)\n        .map(chunk => ({ name: chunk }));\n    } else {\n      contentChunks = [{ name: sanitizedContent }];\n    }\n    \n    mainNode.children.push({\n      type: 'field',\n      attributeId: fieldIds.Content,\n      children: contentChunks\n    });\n  }\n\n  return {\n    targetNodeId,\n    nodes: [mainNode]\n  };\n}\n","import { \n  SaveData, \n  SaveResponse, \n  TanaConfig, \n  ExtensionRequest,\n  SaveToTanaRequest,\n  ExtractContentRequest,\n  InjectOverlayRequest,\n  QuickSaveRequest,\n  SaveWithNotesRequest,\n  TanaPayload\n} from './types/index';\nimport { buildTanaPayload } from './tanaPayloadBuilder';\n\n/**\n * Background script - handles API communication with Tana and orchestrates extension events\n */\n\n// Rate limiting to prevent \"Token was used too recently\" errors\nlet lastApiCall = 0;\nconst MIN_API_INTERVAL = 2000; // 2 seconds between API calls\n\n// Extension installation and setup\nchrome.runtime.onInstalled.addListener(async () => {\n  console.log('Save to Tana extension installed');\n  await setupContextMenus();\n});\n\n// Omnibox integration - handles \"tana\" keyword searches\nchrome.omnibox.onInputStarted.addListener(() => {\n  console.log('Omnibox input started for Save to Tana');\n});\n\nchrome.omnibox.onInputChanged.addListener((text, suggest) => {\n  // Provide search suggestions based on input\n  const suggestions = [];\n  \n  if (text.trim() === '') {\n    // Empty input - suggest default actions\n    suggestions.push({\n      content: 'quick',\n      description: 'Quick save current page'\n    });\n    suggestions.push({\n      content: 'notes',\n      description: 'Save with notes dialog'\n    });\n  } else {\n    // User typed something - treat as custom title\n    suggestions.push({\n      content: text,\n      description: `Save current page with title: \"${text}\"`\n    });\n    suggestions.push({\n      content: `quick`,\n      description: `Quick save current page (original title)`\n    });\n  }\n  \n  suggest(suggestions);\n});\n\nchrome.omnibox.onInputEntered.addListener(async (text, disposition) => {\n  const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true });\n  if (!activeTab?.id) return;\n\n  if (text === 'quick') {\n    // Quick save\n    await handleQuickSave(activeTab.id);\n  } else if (text === 'notes') {\n    // Save with notes dialog\n    await handleSaveWithNotes(activeTab.id);\n  } else {\n    // User typed text - treat as custom title\n    await handleSaveWithCustomTitle(activeTab.id, text.trim());\n  }\n});\n\n// Keyboard command handlers\nchrome.commands.onCommand.addListener(async (command) => {\n  console.log(`🎹 KEYBOARD COMMAND RECEIVED: ${command}`);\n  \n  // Show immediate notification that command was received\n  showNotification(`Keyboard command received: ${command}`, 'success');\n  \n  const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true });\n  if (!activeTab?.id) {\n    console.log('❌ No active tab found');\n    showNotification('No active tab found', 'error');\n    return;\n  }\n\n  console.log(`📋 Processing command \"${command}\" for tab ${activeTab.id}: ${activeTab.title}`);\n\n  switch (command) {\n    case 'quick-save':\n      console.log('🚀 Executing quick save...');\n      await handleQuickSave(activeTab.id);\n      break;\n    case 'save-with-notes':\n      console.log('📝 Executing save with notes...');\n      await handleSaveWithNotes(activeTab.id);\n      break;\n    default:\n      console.log(`❓ Unknown command: ${command}`);\n      showNotification(`Unknown command: ${command}`, 'error');\n  }\n});\n\n// Context menu event handlers\nchrome.contextMenus.onClicked.addListener(async (info, tab) => {\n  if (!tab?.id) return;\n\n  switch (info.menuItemId) {\n    case 'save-page':\n      await handleQuickSave(tab.id);\n      break;\n    case 'save-with-notes':\n      await handleSaveWithNotes(tab.id);\n      break;\n    case 'save-selection':\n      if (info.selectionText) {\n        await handleSaveSelection(tab.id, info.selectionText);\n      }\n      break;\n    default:\n      console.log(`Unknown context menu item: ${info.menuItemId}`);\n  }\n});\n\n// Enhanced message handler for all extension communication\nchrome.runtime.onMessage.addListener((\n  request: ExtensionRequest, \n  sender: chrome.runtime.MessageSender, \n  sendResponse: (response: SaveResponse | any) => void\n) => {\n  console.log(`Message received: ${request.action}`, request);\n\n  switch (request.action) {\n    case 'saveToTana':\n      handleSaveToTanaMessage(request as SaveToTanaRequest, sendResponse);\n      return true; // Async response\n\n    case 'extractContent':\n      // This is handled by content script, but we can log it\n      console.log('Extract content request forwarded to content script');\n      return false;\n\n    case 'injectOverlay':\n      handleInjectOverlay(request as InjectOverlayRequest, sendResponse);\n      return true; // Async response\n\n    case 'quickSave':\n      handleQuickSaveMessage(request as QuickSaveRequest, sendResponse);\n      return true; // Async response\n\n    case 'saveWithNotes':\n      handleSaveWithNotesMessage(request as SaveWithNotesRequest, sendResponse);\n      return true; // Async response\n\n\n    default:\n      console.log(`Unknown message action: ${request.action}`);\n      sendResponse({ success: false, error: 'Unknown action' });\n      return false;\n  }\n});\n\n/**\n * Function to save data to Tana\n * @param data - The data to save to Tana\n * @returns Promise resolving to a SaveResponse\n */\nasync function saveToTana(data: SaveData): Promise<SaveResponse> {\n  try {\n    console.log('Starting saveToTana with data:', data);\n    \n    // Rate limiting check\n    const now = Date.now();\n    const timeSinceLastCall = now - lastApiCall;\n    if (timeSinceLastCall < MIN_API_INTERVAL) {\n      const waitTime = MIN_API_INTERVAL - timeSinceLastCall;\n      console.log(`Rate limiting: waiting ${waitTime}ms before API call`);\n      await new Promise(resolve => setTimeout(resolve, waitTime));\n    }\n    \n    // Get API key, target node ID, and schema info from storage\n    const result = await getStorageConfig();\n    \n    console.log('Retrieved configuration from storage:', result);\n    validateConfig(result);\n    \n    const targetNodeId = result.targetNodeId;\n    console.log('Using target node ID:', targetNodeId);\n    \n    // Build the payload using the schema\n    const tanaPayload = buildTanaPayload(\n      data, \n      targetNodeId, \n      result.supertagId, \n      result.tanaFieldIds\n    );\n    console.log('Formatted Tana payload:', tanaPayload);\n    \n    // Send data to Tana API\n    lastApiCall = Date.now(); // Update timestamp before API call\n    const responseData = await sendToTanaApi(tanaPayload, result.apiKey);\n    \n    return {\n      success: true,\n      data: responseData\n    };\n  } catch (error) {\n    console.error('Error saving to Tana:', error);\n    throw error;\n  }\n}\n\n/**\n * Get configuration from Chrome storage\n * @returns Promise resolving to TanaConfig\n */\nasync function getStorageConfig(): Promise<TanaConfig> {\n  return new Promise((resolve, reject) => {\n    chrome.storage.sync.get(\n      ['apiKey', 'targetNodeId', 'supertagId', 'tanaFieldIds'], \n      (result) => {\n        try {\n          validateConfig(result);\n          resolve(result as TanaConfig);\n        } catch (error) {\n          reject(error);\n        }\n      }\n    );\n  });\n}\n\n/**\n * Validate the configuration\n * @param config - The configuration to validate\n * @throws Error if configuration is invalid\n */\nfunction validateConfig(config: Partial<TanaConfig>): asserts config is TanaConfig {\n  if (!config.apiKey) {\n    throw new Error('API Token not configured. Please go to extension options and set up your configuration.');\n  }\n  \n  if (!config.supertagId) {\n    throw new Error('Supertag ID not configured. Please extract and save your Tana schema in options.');\n  }\n  \n  if (!config.targetNodeId) {\n    throw new Error('Target Node ID is required. Please go to options and specify a target node ID.');\n  }\n  \n  if (!config.tanaFieldIds) {\n    throw new Error('Field IDs not configured. Please extract and save your Tana schema in options.');\n  }\n}\n\n/**\n * Send payload to Tana API\n * @param payload - The payload to send\n * @param apiKey - The API key for authentication\n * @returns Promise resolving to the API response data\n */\nasync function sendToTanaApi(payload: TanaPayload, apiKey: string): Promise<any> {\n  console.log('Sending request to Tana API...');\n  const response = await fetch('https://europe-west1-tagr-prod.cloudfunctions.net/addToNodeV2', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${apiKey}`\n    },\n    body: JSON.stringify(payload)\n  });\n  \n  console.log('API response status:', response.status);\n  \n  if (!response.ok) {\n    const errorText = await response.text();\n    console.error('API error response:', errorText);\n    throw new Error(`API error (${response.status}): ${errorText}`);\n  }\n  \n  const responseData = await response.json();\n  console.log('API success response:', responseData);\n  return responseData;\n}\n\n// ===== Event Handler Functions =====\n\n/**\n * Setup context menus for the extension\n */\nasync function setupContextMenus(): Promise<void> {\n  try {\n    // Remove all existing context menus first\n    await chrome.contextMenus.removeAll();\n\n    // Create main context menu items\n    chrome.contextMenus.create({\n      id: 'save-page',\n      title: 'Save page to Tana',\n      contexts: ['page']\n    });\n\n    chrome.contextMenus.create({\n      id: 'save-with-notes',\n      title: 'Save page to Tana with notes',\n      contexts: ['page']\n    });\n\n    chrome.contextMenus.create({\n      id: 'save-selection',\n      title: 'Save selection to Tana',\n      contexts: ['selection']\n    });\n\n    console.log('Context menus created successfully');\n  } catch (error) {\n    console.error('Error setting up context menus:', error);\n  }\n}\n\n/**\n * Handle saveToTana message (maintains backward compatibility)\n */\nasync function handleSaveToTanaMessage(\n  request: SaveToTanaRequest, \n  sendResponse: (response: SaveResponse) => void\n): Promise<void> {\n  try {\n    const result = await saveToTana(request.data);\n    sendResponse(result);\n  } catch (error) {\n    sendResponse({\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred'\n    });\n  }\n}\n\n/**\n * Handle overlay injection requests\n */\nasync function handleInjectOverlay(\n  request: InjectOverlayRequest,\n  sendResponse: (response: SaveResponse) => void\n): Promise<void> {\n  try {\n    // Inject content script if not already present\n    await chrome.scripting.executeScript({\n      target: { tabId: request.tabId },\n      files: ['content.js']\n    });\n\n    // You could also inject overlay-specific scripts here\n    // await chrome.scripting.executeScript({\n    //   target: { tabId: request.tabId },\n    //   files: ['overlay.js']\n    // });\n\n    sendResponse({ success: true });\n  } catch (error) {\n    console.error('Error injecting overlay:', error);\n    sendResponse({\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to inject overlay'\n    });\n  }\n}\n\n/**\n * Handle quick save requests from messages\n */\nasync function handleQuickSaveMessage(\n  request: QuickSaveRequest,\n  sendResponse: (response: SaveResponse) => void\n): Promise<void> {\n  try {\n    const result = await performQuickSave(request.tabId);\n    sendResponse(result);\n  } catch (error) {\n    sendResponse({\n      success: false,\n      error: error instanceof Error ? error.message : 'Quick save failed'\n    });\n  }\n}\n\n/**\n * Handle save with notes requests from messages\n */\nasync function handleSaveWithNotesMessage(\n  request: SaveWithNotesRequest,\n  sendResponse: (response: SaveResponse) => void\n): Promise<void> {\n  try {\n    // For save with notes, we need to open the popup or overlay\n    // This will typically be handled by injecting an overlay content script\n    await handleInjectOverlay({ action: 'injectOverlay', tabId: request.tabId }, (response) => {\n      if (response.success) {\n        // Send message to the tab to show the notes dialog\n        chrome.tabs.sendMessage(request.tabId, {\n          action: 'showNotesDialog'\n        });\n      }\n    });\n    \n    sendResponse({ success: true });\n  } catch (error) {\n    sendResponse({\n      success: false,\n      error: error instanceof Error ? error.message : 'Save with notes failed'\n    });\n  }\n}\n\n\n/**\n * Handle quick save from keyboard shortcut or context menu\n */\nasync function handleQuickSave(tabId: number): Promise<void> {\n  try {\n    const result = await performQuickSave(tabId);\n    \n    // Show notification to user\n    if (result.success) {\n      showNotification('Page saved to Tana successfully!', 'success');\n    } else {\n      showNotification(result.error || 'Save failed', 'error');\n    }\n  } catch (error) {\n    console.error('Quick save error:', error);\n    showNotification('Quick save failed', 'error');\n  }\n}\n\n/**\n * Handle save with notes from keyboard shortcut or context menu\n */\nasync function handleSaveWithNotes(tabId: number): Promise<void> {\n  try {\n    // Inject overlay for notes dialog\n    await handleInjectOverlay({ action: 'injectOverlay', tabId }, (response) => {\n      if (response.success) {\n        // Send message to show notes dialog\n        chrome.tabs.sendMessage(tabId, {\n          action: 'showNotesDialog'\n        });\n      } else {\n        showNotification('Failed to open notes dialog', 'error');\n      }\n    });\n  } catch (error) {\n    console.error('Save with notes error:', error);\n    showNotification('Failed to open notes dialog', 'error');\n  }\n}\n\n/**\n * Handle save with custom notes from omnibox\n */\nasync function handleSaveWithCustomTitle(tabId: number, customNotes: string): Promise<void> {\n  try {\n    // Extract content first\n    const pageData = await extractPageContent(tabId);\n    if (pageData) {\n      // Add notes as separate field, keep content clean\n      if (customNotes.trim()) {\n        pageData.notes = customNotes;\n      }\n      \n      const result = await saveToTana(pageData);\n      \n      if (result.success) {\n        showNotification(`Page saved to Tana with notes: \"${customNotes}\"`, 'success');\n      } else {\n        showNotification(result.error || 'Save failed', 'error');\n      }\n    } else {\n      showNotification('Failed to extract page content', 'error');\n    }\n  } catch (error) {\n    console.error('Save with custom notes error:', error);\n    showNotification('Save with custom notes failed', 'error');\n  }\n}\n\n/**\n * Handle saving selected text\n */\nasync function handleSaveSelection(tabId: number, selectionText: string): Promise<void> {\n  try {\n    // Get basic page data and combine with selection\n    const pageData = await extractPageContent(tabId, { includeContent: false });\n    if (pageData) {\n      // Use selection as content\n      pageData.content = selectionText;\n      pageData.title = `Selection from ${pageData.title}`;\n      \n      const result = await saveToTana(pageData);\n      \n      if (result.success) {\n        showNotification('Selection saved to Tana successfully!', 'success');\n      } else {\n        showNotification(result.error || 'Save failed', 'error');\n      }\n    }\n  } catch (error) {\n    console.error('Save selection error:', error);\n    showNotification('Save selection failed', 'error');\n  }\n}\n\n/**\n * Perform quick save operation\n */\nasync function performQuickSave(tabId: number): Promise<SaveResponse> {\n  try {\n    const pageData = await extractPageContent(tabId);\n    if (!pageData) {\n      throw new Error('Failed to extract page content');\n    }\n    \n    return await saveToTana(pageData);\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Quick save failed'\n    };\n  }\n}\n\n/**\n * Extract page content from a tab\n */\nasync function extractPageContent(\n  tabId: number, \n  options: { includeContent?: boolean; includeTitle?: boolean } = {}\n): Promise<SaveData | null> {\n  return new Promise((resolve) => {\n    const extractOptions = {\n      includeContent: options.includeContent ?? true,\n      includeTitle: options.includeTitle ?? true\n    };\n\n    chrome.tabs.sendMessage(\n      tabId,\n      { action: 'extractContent', options: extractOptions },\n      (response) => {\n        if (chrome.runtime.lastError) {\n          console.error('Content extraction error:', chrome.runtime.lastError);\n          resolve(null);\n          return;\n        }\n        \n        if (response && !response.error) {\n          resolve({\n            url: response.url,\n            title: response.title,\n            author: response.author,\n            description: response.description,\n            content: response.content\n          });\n        } else {\n          console.error('Content extraction failed:', response?.message);\n          resolve(null);\n        }\n      }\n    );\n  });\n}\n\n/**\n * Show notification to user\n */\nfunction showNotification(message: string, type: 'success' | 'error' = 'success'): void {\n  const notificationId = `tana-${Date.now()}`;\n  \n  try {\n    chrome.notifications.create(notificationId, {\n      type: 'basic',\n      iconUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==', // 1x1 transparent pixel\n      title: 'Save to Tana',\n      message: message\n    });\n\n    // Auto-clear notification after 3 seconds\n    setTimeout(() => {\n      chrome.notifications.clear(notificationId);\n    }, 3000);\n  } catch (error) {\n    console.log('Notification error (non-critical):', error);\n    // Fallback: just log the message if notifications fail\n    console.log(`Save to Tana: ${message}`);\n  }\n}\n"],"names":["sanitizeText","text","splitIntoChunks","content","maxSize","paragraphs","chunks","currentChunk","paragraph","sentences","sentence","i","buildTanaPayload","data","targetNodeId","supertagId","fieldIds","mainNode","sanitizedContent","maxContentLength","contentChunks","chunk","lastApiCall","MIN_API_INTERVAL","setupContextMenus","suggest","suggestions","disposition","activeTab","handleQuickSave","handleSaveWithNotes","handleSaveWithCustomTitle","command","showNotification","info","tab","handleSaveSelection","request","sender","sendResponse","handleSaveToTanaMessage","handleInjectOverlay","handleQuickSaveMessage","handleSaveWithNotesMessage","saveToTana","timeSinceLastCall","waitTime","resolve","result","getStorageConfig","validateConfig","tanaPayload","sendToTanaApi","error","reject","config","payload","apiKey","response","errorText","responseData","performQuickSave","tabId","customNotes","pageData","extractPageContent","selectionText","options","extractOptions","message","type","notificationId"],"mappings":"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"}