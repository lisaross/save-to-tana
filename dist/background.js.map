{"version":3,"file":"background.js","sources":["../src/utils/textUtils.ts","../src/tanaPayloadBuilder.ts","../src/background.ts"],"sourcesContent":["/**\n * Utility functions for text processing\n */\n\n/**\n * Sanitizes text for Tana API by removing newlines and extra spaces\n * @param text - The text to sanitize\n * @returns Sanitized text\n */\nexport function sanitizeText(text: string | undefined): string {\n  if (!text) return '';\n  \n  return text\n    .replace(/\\r?\\n|\\r/g, ' ')  // Replace newlines with spaces\n    .replace(/\\s+/g, ' ')       // Replace multiple spaces with a single space\n    .trim();\n}\n\n/**\n * Splits content into chunks of specified maximum size\n * @param content - The content to split\n * @param maxSize - Maximum size of each chunk\n * @returns Array of content chunks\n */\nexport function splitIntoChunks(content: string, maxSize: number): string[] {\n  const paragraphs = content.split(/\\n\\n+/);\n  const chunks: string[] = [];\n  let currentChunk = '';\n  \n  for (const paragraph of paragraphs) {\n    if ((currentChunk + paragraph).length > maxSize) {\n      if (currentChunk) {\n        chunks.push(currentChunk);\n        currentChunk = '';\n      }\n      \n      if (paragraph.length > maxSize) {\n        const sentences = paragraph.match(/[^.!?]+[.!?]+/g) || [paragraph];\n        \n        for (const sentence of sentences) {\n          if (sentence.length > maxSize) {\n            for (let i = 0; i < sentence.length; i += maxSize) {\n              chunks.push(sentence.slice(i, i + maxSize));\n            }\n          } else {\n            if ((currentChunk + sentence).length > maxSize) {\n              chunks.push(currentChunk);\n              currentChunk = sentence;\n            } else {\n              currentChunk += sentence;\n            }\n          }\n        }\n      } else {\n        currentChunk = paragraph;\n      }\n    } else {\n      currentChunk += (currentChunk ? '\\n\\n' : '') + paragraph;\n    }\n  }\n  \n  if (currentChunk) {\n    chunks.push(currentChunk);\n  }\n  \n  return chunks;\n}\n","import { \n  SaveData, \n  TanaFieldIds, \n  TanaPayload, \n  TanaNode,\n  TanaNodeChildContent\n} from './types/index';\nimport { sanitizeText, splitIntoChunks } from './utils/textUtils';\n\n/**\n * Build a Tana API payload using the extracted schema and content data.\n * @param data - The content data (url, title, author, description, content)\n * @param targetNodeId - The Tana node to save under\n * @param supertagId - The supertag ID for the node\n * @param fieldIds - Mapping of field names to attribute IDs\n * @returns Tana API payload\n */\nexport function buildTanaPayload(\n  data: SaveData, \n  targetNodeId: string, \n  supertagId: string, \n  fieldIds: TanaFieldIds\n): TanaPayload {\n  // Validate required parameters\n  if (!data) {\n    throw new Error('SaveData is required');\n  }\n  if (!targetNodeId || !targetNodeId.trim()) {\n    throw new Error('Valid targetNodeId is required');\n  }\n  if (!supertagId || !supertagId.trim()) {\n    throw new Error('Valid supertagId is required');\n  }\n  if (!fieldIds) {\n    throw new Error('TanaFieldIds is required');\n  }\n\n  // Build the main node\n  const mainNode: TanaNode = {\n    name: sanitizeText(data.title || data.url),\n    supertags: [{ id: supertagId }],\n    children: []\n  };\n\n  // Add URL field\n  if (data.url && fieldIds.URL) {\n    mainNode.children.push({\n      type: 'field',\n      attributeId: fieldIds.URL,\n      children: [{ dataType: 'url', name: data.url }]\n    });\n  }\n  \n  // Add Author field\n  if (data.author && fieldIds.Author) {\n    mainNode.children.push({\n      type: 'field',\n      attributeId: fieldIds.Author,\n      children: [{ name: sanitizeText(data.author) }]\n    });\n  }\n  \n  // Add Description field\n  if (data.description && fieldIds.Description) {\n    mainNode.children.push({\n      type: 'field',\n      attributeId: fieldIds.Description,\n      children: [{ name: sanitizeText(data.description) }]\n    });\n  }\n  \n  // Add Content field (chunked if needed)\n  if (data.content && fieldIds.Content) {\n    const sanitizedContent = sanitizeText(data.content);\n    const maxContentLength = 4000;\n    let contentChunks: TanaNodeChildContent[] = [];\n    \n    if (sanitizedContent.length > maxContentLength) {\n      contentChunks = splitIntoChunks(sanitizedContent, maxContentLength)\n        .map(chunk => ({ name: chunk }));\n    } else {\n      contentChunks = [{ name: sanitizedContent }];\n    }\n    \n    mainNode.children.push({\n      type: 'field',\n      attributeId: fieldIds.Content,\n      children: contentChunks\n    });\n  }\n\n  return {\n    targetNodeId,\n    nodes: [mainNode]\n  };\n}\n","import { \n  SaveData, \n  SaveResponse, \n  TanaConfig, \n  ExtensionRequest,\n  SaveToTanaRequest,\n  ExtractContentRequest,\n  InjectOverlayRequest,\n  QuickSaveRequest,\n  SaveWithNotesRequest,\n  TanaPayload\n} from './types/index';\nimport { buildTanaPayload } from './tanaPayloadBuilder';\n\n/**\n * Background script - handles API communication with Tana and orchestrates extension events\n */\n\n// Extension installation and setup\nchrome.runtime.onInstalled.addListener(async () => {\n  console.log('Save to Tana extension installed');\n  await setupContextMenus();\n});\n\n// Omnibox integration - handles \"tana\" keyword searches\nchrome.omnibox.onInputStarted.addListener(() => {\n  console.log('Omnibox input started for Save to Tana');\n});\n\nchrome.omnibox.onInputChanged.addListener((text, suggest) => {\n  // Provide search suggestions based on input\n  const suggestions = [\n    {\n      content: `save:${text}`,\n      description: `Save current page with title: \"${text}\"`\n    },\n    {\n      content: `quick:${text}`,\n      description: `Quick save current page (${text})`\n    }\n  ];\n  suggest(suggestions);\n});\n\nchrome.omnibox.onInputEntered.addListener(async (text, disposition) => {\n  const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true });\n  if (!activeTab?.id) return;\n\n  if (text.startsWith('save:')) {\n    // Save with custom title\n    const customTitle = text.substring(5).trim();\n    await handleSaveWithCustomTitle(activeTab.id, customTitle);\n  } else if (text.startsWith('quick:')) {\n    // Quick save\n    await handleQuickSave(activeTab.id);\n  } else {\n    // Default: open the popup\n    await chrome.action.openPopup();\n  }\n});\n\n// Keyboard command handlers\nchrome.commands.onCommand.addListener(async (command) => {\n  console.log(`Command received: ${command}`);\n  \n  const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true });\n  if (!activeTab?.id) return;\n\n  switch (command) {\n    case 'quick-save':\n      await handleQuickSave(activeTab.id);\n      break;\n    case 'save-with-notes':\n      await handleSaveWithNotes(activeTab.id);\n      break;\n    default:\n      console.log(`Unknown command: ${command}`);\n  }\n});\n\n// Context menu event handlers\nchrome.contextMenus.onClicked.addListener(async (info, tab) => {\n  if (!tab?.id) return;\n\n  switch (info.menuItemId) {\n    case 'save-page':\n      await handleQuickSave(tab.id);\n      break;\n    case 'save-with-notes':\n      await handleSaveWithNotes(tab.id);\n      break;\n    case 'save-selection':\n      if (info.selectionText) {\n        await handleSaveSelection(tab.id, info.selectionText);\n      }\n      break;\n    default:\n      console.log(`Unknown context menu item: ${info.menuItemId}`);\n  }\n});\n\n// Enhanced message handler for all extension communication\nchrome.runtime.onMessage.addListener((\n  request: ExtensionRequest, \n  sender: chrome.runtime.MessageSender, \n  sendResponse: (response: SaveResponse | any) => void\n) => {\n  console.log(`Message received: ${request.action}`, request);\n\n  switch (request.action) {\n    case 'saveToTana':\n      handleSaveToTanaMessage(request as SaveToTanaRequest, sendResponse);\n      return true; // Async response\n\n    case 'extractContent':\n      // This is handled by content script, but we can log it\n      console.log('Extract content request forwarded to content script');\n      return false;\n\n    case 'injectOverlay':\n      handleInjectOverlay(request as InjectOverlayRequest, sendResponse);\n      return true; // Async response\n\n    case 'quickSave':\n      handleQuickSaveMessage(request as QuickSaveRequest, sendResponse);\n      return true; // Async response\n\n    case 'saveWithNotes':\n      handleSaveWithNotesMessage(request as SaveWithNotesRequest, sendResponse);\n      return true; // Async response\n\n    default:\n      console.log(`Unknown message action: ${request.action}`);\n      sendResponse({ success: false, error: 'Unknown action' });\n      return false;\n  }\n});\n\n/**\n * Function to save data to Tana\n * @param data - The data to save to Tana\n * @returns Promise resolving to a SaveResponse\n */\nasync function saveToTana(data: SaveData): Promise<SaveResponse> {\n  try {\n    console.log('Starting saveToTana with data:', data);\n    \n    // Get API key, target node ID, and schema info from storage\n    const result = await getStorageConfig();\n    \n    console.log('Retrieved configuration from storage:', result);\n    validateConfig(result);\n    \n    const targetNodeId = result.targetNodeId;\n    console.log('Using target node ID:', targetNodeId);\n    \n    // Build the payload using the schema\n    const tanaPayload = buildTanaPayload(\n      data, \n      targetNodeId, \n      result.supertagId, \n      result.tanaFieldIds\n    );\n    console.log('Formatted Tana payload:', tanaPayload);\n    \n    // Send data to Tana API\n    const responseData = await sendToTanaApi(tanaPayload, result.apiKey);\n    \n    return {\n      success: true,\n      data: responseData\n    };\n  } catch (error) {\n    console.error('Error saving to Tana:', error);\n    throw error;\n  }\n}\n\n/**\n * Get configuration from Chrome storage\n * @returns Promise resolving to TanaConfig\n */\nasync function getStorageConfig(): Promise<TanaConfig> {\n  return new Promise((resolve, reject) => {\n    chrome.storage.sync.get(\n      ['apiKey', 'targetNodeId', 'supertagId', 'tanaFieldIds'], \n      (result) => {\n        try {\n          validateConfig(result);\n          resolve(result as TanaConfig);\n        } catch (error) {\n          reject(error);\n        }\n      }\n    );\n  });\n}\n\n/**\n * Validate the configuration\n * @param config - The configuration to validate\n * @throws Error if configuration is invalid\n */\nfunction validateConfig(config: Partial<TanaConfig>): asserts config is TanaConfig {\n  if (!config.apiKey) {\n    throw new Error('API Token not configured. Please go to extension options and set up your configuration.');\n  }\n  \n  if (!config.supertagId) {\n    throw new Error('Supertag ID not configured. Please extract and save your Tana schema in options.');\n  }\n  \n  if (!config.targetNodeId) {\n    throw new Error('Target Node ID is required. Please go to options and specify a target node ID.');\n  }\n  \n  if (!config.tanaFieldIds) {\n    throw new Error('Field IDs not configured. Please extract and save your Tana schema in options.');\n  }\n}\n\n/**\n * Send payload to Tana API\n * @param payload - The payload to send\n * @param apiKey - The API key for authentication\n * @returns Promise resolving to the API response data\n */\nasync function sendToTanaApi(payload: TanaPayload, apiKey: string): Promise<any> {\n  console.log('Sending request to Tana API...');\n  const response = await fetch('https://europe-west1-tagr-prod.cloudfunctions.net/addToNodeV2', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${apiKey}`\n    },\n    body: JSON.stringify(payload)\n  });\n  \n  console.log('API response status:', response.status);\n  \n  if (!response.ok) {\n    const errorText = await response.text();\n    console.error('API error response:', errorText);\n    throw new Error(`API error (${response.status}): ${errorText}`);\n  }\n  \n  const responseData = await response.json();\n  console.log('API success response:', responseData);\n  return responseData;\n}\n\n// ===== Event Handler Functions =====\n\n/**\n * Setup context menus for the extension\n */\nasync function setupContextMenus(): Promise<void> {\n  try {\n    // Remove all existing context menus first\n    await chrome.contextMenus.removeAll();\n\n    // Create main context menu items\n    chrome.contextMenus.create({\n      id: 'save-page',\n      title: 'Save page to Tana',\n      contexts: ['page']\n    });\n\n    chrome.contextMenus.create({\n      id: 'save-with-notes',\n      title: 'Save page to Tana with notes',\n      contexts: ['page']\n    });\n\n    chrome.contextMenus.create({\n      id: 'save-selection',\n      title: 'Save selection to Tana',\n      contexts: ['selection']\n    });\n\n    console.log('Context menus created successfully');\n  } catch (error) {\n    console.error('Error setting up context menus:', error);\n  }\n}\n\n/**\n * Handle saveToTana message (maintains backward compatibility)\n */\nasync function handleSaveToTanaMessage(\n  request: SaveToTanaRequest, \n  sendResponse: (response: SaveResponse) => void\n): Promise<void> {\n  try {\n    const result = await saveToTana(request.data);\n    sendResponse(result);\n  } catch (error) {\n    sendResponse({\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred'\n    });\n  }\n}\n\n/**\n * Handle overlay injection requests\n */\nasync function handleInjectOverlay(\n  request: InjectOverlayRequest,\n  sendResponse: (response: SaveResponse) => void\n): Promise<void> {\n  try {\n    // Inject content script if not already present\n    await chrome.scripting.executeScript({\n      target: { tabId: request.tabId },\n      files: ['content.js']\n    });\n\n    // You could also inject overlay-specific scripts here\n    // await chrome.scripting.executeScript({\n    //   target: { tabId: request.tabId },\n    //   files: ['overlay.js']\n    // });\n\n    sendResponse({ success: true });\n  } catch (error) {\n    console.error('Error injecting overlay:', error);\n    sendResponse({\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to inject overlay'\n    });\n  }\n}\n\n/**\n * Handle quick save requests from messages\n */\nasync function handleQuickSaveMessage(\n  request: QuickSaveRequest,\n  sendResponse: (response: SaveResponse) => void\n): Promise<void> {\n  try {\n    const result = await performQuickSave(request.tabId);\n    sendResponse(result);\n  } catch (error) {\n    sendResponse({\n      success: false,\n      error: error instanceof Error ? error.message : 'Quick save failed'\n    });\n  }\n}\n\n/**\n * Handle save with notes requests from messages\n */\nasync function handleSaveWithNotesMessage(\n  request: SaveWithNotesRequest,\n  sendResponse: (response: SaveResponse) => void\n): Promise<void> {\n  try {\n    // For save with notes, we need to open the popup or overlay\n    // This will typically be handled by injecting an overlay content script\n    await handleInjectOverlay({ action: 'injectOverlay', tabId: request.tabId }, (response) => {\n      if (response.success) {\n        // Send message to the tab to show the notes dialog\n        chrome.tabs.sendMessage(request.tabId, {\n          action: 'showNotesDialog'\n        });\n      }\n    });\n    \n    sendResponse({ success: true });\n  } catch (error) {\n    sendResponse({\n      success: false,\n      error: error instanceof Error ? error.message : 'Save with notes failed'\n    });\n  }\n}\n\n/**\n * Handle quick save from keyboard shortcut or context menu\n */\nasync function handleQuickSave(tabId: number): Promise<void> {\n  try {\n    const result = await performQuickSave(tabId);\n    \n    // Show notification to user\n    if (result.success) {\n      showNotification('Page saved to Tana successfully!', 'success');\n    } else {\n      showNotification(result.error || 'Save failed', 'error');\n    }\n  } catch (error) {\n    console.error('Quick save error:', error);\n    showNotification('Quick save failed', 'error');\n  }\n}\n\n/**\n * Handle save with notes from keyboard shortcut or context menu\n */\nasync function handleSaveWithNotes(tabId: number): Promise<void> {\n  try {\n    // Inject overlay for notes dialog\n    await handleInjectOverlay({ action: 'injectOverlay', tabId }, (response) => {\n      if (response.success) {\n        // Send message to show notes dialog\n        chrome.tabs.sendMessage(tabId, {\n          action: 'showNotesDialog'\n        });\n      } else {\n        showNotification('Failed to open notes dialog', 'error');\n      }\n    });\n  } catch (error) {\n    console.error('Save with notes error:', error);\n    showNotification('Failed to open notes dialog', 'error');\n  }\n}\n\n/**\n * Handle save with custom title from omnibox\n */\nasync function handleSaveWithCustomTitle(tabId: number, customTitle: string): Promise<void> {\n  try {\n    // Extract content first\n    const pageData = await extractPageContent(tabId);\n    if (pageData) {\n      // Override the title with custom title\n      pageData.title = customTitle;\n      const result = await saveToTana(pageData);\n      \n      if (result.success) {\n        showNotification(`Page saved to Tana with title: \"${customTitle}\"`, 'success');\n      } else {\n        showNotification(result.error || 'Save failed', 'error');\n      }\n    }\n  } catch (error) {\n    console.error('Save with custom title error:', error);\n    showNotification('Save with custom title failed', 'error');\n  }\n}\n\n/**\n * Handle saving selected text\n */\nasync function handleSaveSelection(tabId: number, selectionText: string): Promise<void> {\n  try {\n    // Get basic page data and combine with selection\n    const pageData = await extractPageContent(tabId, { includeContent: false });\n    if (pageData) {\n      // Use selection as content\n      pageData.content = selectionText;\n      pageData.title = `Selection from ${pageData.title}`;\n      \n      const result = await saveToTana(pageData);\n      \n      if (result.success) {\n        showNotification('Selection saved to Tana successfully!', 'success');\n      } else {\n        showNotification(result.error || 'Save failed', 'error');\n      }\n    }\n  } catch (error) {\n    console.error('Save selection error:', error);\n    showNotification('Save selection failed', 'error');\n  }\n}\n\n/**\n * Perform quick save operation\n */\nasync function performQuickSave(tabId: number): Promise<SaveResponse> {\n  try {\n    const pageData = await extractPageContent(tabId);\n    if (!pageData) {\n      throw new Error('Failed to extract page content');\n    }\n    \n    return await saveToTana(pageData);\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Quick save failed'\n    };\n  }\n}\n\n/**\n * Extract page content from a tab\n */\nasync function extractPageContent(\n  tabId: number, \n  options: { includeContent?: boolean; includeTitle?: boolean } = {}\n): Promise<SaveData | null> {\n  return new Promise((resolve) => {\n    const extractOptions = {\n      includeContent: options.includeContent ?? true,\n      includeTitle: options.includeTitle ?? true\n    };\n\n    chrome.tabs.sendMessage(\n      tabId,\n      { action: 'extractContent', options: extractOptions },\n      (response) => {\n        if (chrome.runtime.lastError) {\n          console.error('Content extraction error:', chrome.runtime.lastError);\n          resolve(null);\n          return;\n        }\n        \n        if (response && !response.error) {\n          resolve({\n            url: response.url,\n            title: response.title,\n            author: response.author,\n            description: response.description,\n            content: response.content\n          });\n        } else {\n          console.error('Content extraction failed:', response?.message);\n          resolve(null);\n        }\n      }\n    );\n  });\n}\n\n/**\n * Show notification to user\n */\nfunction showNotification(message: string, type: 'success' | 'error' = 'success'): void {\n  const notificationId = `tana-${Date.now()}`;\n  \n  chrome.notifications.create(notificationId, {\n    type: 'basic',\n    iconUrl: 'images/icon48.png',\n    title: 'Save to Tana',\n    message: message\n  });\n\n  // Auto-clear notification after 3 seconds\n  setTimeout(() => {\n    chrome.notifications.clear(notificationId);\n  }, 3000);\n}\n"],"names":["sanitizeText","text","splitIntoChunks","content","maxSize","paragraphs","chunks","currentChunk","paragraph","sentences","sentence","buildTanaPayload","data","targetNodeId","supertagId","fieldIds","mainNode","sanitizedContent","maxContentLength","contentChunks","chunk","setupContextMenus","suggest","suggestions","disposition","activeTab","customTitle","handleSaveWithCustomTitle","handleQuickSave","command","handleSaveWithNotes","info","tab","handleSaveSelection","request","sender","sendResponse","handleSaveToTanaMessage","handleInjectOverlay","handleQuickSaveMessage","handleSaveWithNotesMessage","saveToTana","result","getStorageConfig","validateConfig","tanaPayload","sendToTanaApi","error","resolve","reject","config","payload","apiKey","response","errorText","responseData","performQuickSave","tabId","showNotification","pageData","extractPageContent","selectionText","options","extractOptions","message","type","notificationId"],"mappings":"AASO,SAASA,EAAaC,EAAkC,CACzD,OAACA,EAEEA,EACJ,QAAQ,YAAa,GAAG,EACxB,QAAQ,OAAQ,GAAG,EACnB,KAAK,EALU,EAMpB,CAQgB,SAAAC,EAAgBC,EAAiBC,EAA2B,CACpE,MAAAC,EAAaF,EAAQ,MAAM,OAAO,EAClCG,EAAmB,CAAC,EAC1B,IAAIC,EAAe,GAEnB,UAAWC,KAAaH,EACjB,IAAAE,EAAeC,GAAW,OAASJ,EAMlC,GALAG,IACFD,EAAO,KAAKC,CAAY,EACTA,EAAA,IAGbC,EAAU,OAASJ,EAAS,CAC9B,MAAMK,EAAYD,EAAU,MAAM,gBAAgB,GAAK,CAACA,CAAS,EAEjE,UAAWE,KAAYD,EACjB,GAAAC,EAAS,OAASN,EACpB,QAAS,EAAI,EAAG,EAAIM,EAAS,OAAQ,GAAKN,EACxCE,EAAO,KAAKI,EAAS,MAAM,EAAG,EAAIN,CAAO,CAAC,OAGvCG,EAAeG,GAAU,OAASN,GACrCE,EAAO,KAAKC,CAAY,EACTA,EAAAG,GAECH,GAAAG,CAGtB,MAEeH,EAAAC,OAGAD,IAAAA,EAAe;AAAA;AAAA,EAAS,IAAMC,EAInD,OAAID,GACFD,EAAO,KAAKC,CAAY,EAGnBD,CACT,CCjDO,SAASK,EACdC,EACAC,EACAC,EACAC,EACa,CAEb,GAAI,CAACH,EACG,MAAA,IAAI,MAAM,sBAAsB,EAExC,GAAI,CAACC,GAAgB,CAACA,EAAa,OAC3B,MAAA,IAAI,MAAM,gCAAgC,EAElD,GAAI,CAACC,GAAc,CAACA,EAAW,OACvB,MAAA,IAAI,MAAM,8BAA8B,EAEhD,GAAI,CAACC,EACG,MAAA,IAAI,MAAM,0BAA0B,EAI5C,MAAMC,EAAqB,CACzB,KAAMhB,EAAaY,EAAK,OAASA,EAAK,GAAG,EACzC,UAAW,CAAC,CAAE,GAAIE,EAAY,EAC9B,SAAU,CAAA,CACZ,EA8BI,GA3BAF,EAAK,KAAOG,EAAS,KACvBC,EAAS,SAAS,KAAK,CACrB,KAAM,QACN,YAAaD,EAAS,IACtB,SAAU,CAAC,CAAE,SAAU,MAAO,KAAMH,EAAK,GAAK,CAAA,CAAA,CAC/C,EAICA,EAAK,QAAUG,EAAS,QAC1BC,EAAS,SAAS,KAAK,CACrB,KAAM,QACN,YAAaD,EAAS,OACtB,SAAU,CAAC,CAAE,KAAMf,EAAaY,EAAK,MAAM,CAAG,CAAA,CAAA,CAC/C,EAICA,EAAK,aAAeG,EAAS,aAC/BC,EAAS,SAAS,KAAK,CACrB,KAAM,QACN,YAAaD,EAAS,YACtB,SAAU,CAAC,CAAE,KAAMf,EAAaY,EAAK,WAAW,CAAG,CAAA,CAAA,CACpD,EAICA,EAAK,SAAWG,EAAS,QAAS,CAC9B,MAAAE,EAAmBjB,EAAaY,EAAK,OAAO,EAC5CM,EAAmB,IACzB,IAAIC,EAAwC,CAAC,EAEzCF,EAAiB,OAASC,EACZC,EAAAjB,EAAgBe,EAAkBC,CAAgB,EAC/D,IAAcE,IAAA,CAAE,KAAMA,CAAA,EAAQ,EAEjCD,EAAgB,CAAC,CAAE,KAAMF,EAAkB,EAG7CD,EAAS,SAAS,KAAK,CACrB,KAAM,QACN,YAAaD,EAAS,QACtB,SAAUI,CAAA,CACX,CAAA,CAGI,MAAA,CACL,aAAAN,EACA,MAAO,CAACG,CAAQ,CAClB,CACF,CC5EA,OAAO,QAAQ,YAAY,YAAY,SAAY,CACjD,QAAQ,IAAI,kCAAkC,EAC9C,MAAMK,EAAkB,CAC1B,CAAC,EAGD,OAAO,QAAQ,eAAe,YAAY,IAAM,CAC9C,QAAQ,IAAI,wCAAwC,CACtD,CAAC,EAED,OAAO,QAAQ,eAAe,YAAY,CAACpB,EAAMqB,IAAY,CAE3D,MAAMC,EAAc,CAClB,CACE,QAAS,QAAQtB,CAAI,GACrB,YAAa,kCAAkCA,CAAI,GACrD,EACA,CACE,QAAS,SAASA,CAAI,GACtB,YAAa,4BAA4BA,CAAI,GAAA,CAEjD,EACAqB,EAAQC,CAAW,CACrB,CAAC,EAED,OAAO,QAAQ,eAAe,YAAY,MAAOtB,EAAMuB,IAAgB,CACrE,KAAM,CAACC,CAAS,EAAI,MAAM,OAAO,KAAK,MAAM,CAAE,OAAQ,GAAM,cAAe,EAAA,CAAM,EAC7E,GAACA,GAAW,GAEZ,GAAAxB,EAAK,WAAW,OAAO,EAAG,CAE5B,MAAMyB,EAAczB,EAAK,UAAU,CAAC,EAAE,KAAK,EACrC,MAAA0B,EAA0BF,EAAU,GAAIC,CAAW,CAChD,MAAAzB,EAAK,WAAW,QAAQ,EAE3B,MAAA2B,EAAgBH,EAAU,EAAE,EAG5B,MAAA,OAAO,OAAO,UAAU,CAElC,CAAC,EAGD,OAAO,SAAS,UAAU,YAAY,MAAOI,GAAY,CAC/C,QAAA,IAAI,qBAAqBA,CAAO,EAAE,EAE1C,KAAM,CAACJ,CAAS,EAAI,MAAM,OAAO,KAAK,MAAM,CAAE,OAAQ,GAAM,cAAe,EAAA,CAAM,EAC7E,GAACA,GAAW,GAEhB,OAAQI,EAAS,CACf,IAAK,aACG,MAAAD,EAAgBH,EAAU,EAAE,EAClC,MACF,IAAK,kBACG,MAAAK,EAAoBL,EAAU,EAAE,EACtC,MACF,QACU,QAAA,IAAI,oBAAoBI,CAAO,EAAE,CAAA,CAE/C,CAAC,EAGD,OAAO,aAAa,UAAU,YAAY,MAAOE,EAAMC,IAAQ,CACzD,GAACA,GAAK,GAEV,OAAQD,EAAK,WAAY,CACvB,IAAK,YACG,MAAAH,EAAgBI,EAAI,EAAE,EAC5B,MACF,IAAK,kBACG,MAAAF,EAAoBE,EAAI,EAAE,EAChC,MACF,IAAK,iBACCD,EAAK,eACP,MAAME,EAAoBD,EAAI,GAAID,EAAK,aAAa,EAEtD,MACF,QACE,QAAQ,IAAI,8BAA8BA,EAAK,UAAU,EAAE,CAAA,CAEjE,CAAC,EAGD,OAAO,QAAQ,UAAU,YAAY,CACnCG,EACAC,EACAC,IACG,CAGH,OAFA,QAAQ,IAAI,qBAAqBF,EAAQ,MAAM,GAAIA,CAAO,EAElDA,EAAQ,OAAQ,CACtB,IAAK,aACH,OAAAG,EAAwBH,EAA8BE,CAAY,EAC3D,GAET,IAAK,iBAEH,eAAQ,IAAI,qDAAqD,EAC1D,GAET,IAAK,gBACH,OAAAE,EAAoBJ,EAAiCE,CAAY,EAC1D,GAET,IAAK,YACH,OAAAG,EAAuBL,EAA6BE,CAAY,EACzD,GAET,IAAK,gBACH,OAAAI,EAA2BN,EAAiCE,CAAY,EACjE,GAET,QACE,eAAQ,IAAI,2BAA2BF,EAAQ,MAAM,EAAE,EACvDE,EAAa,CAAE,QAAS,GAAO,MAAO,iBAAkB,EACjD,EAAA,CAEb,CAAC,EAOD,eAAeK,EAAW7B,EAAuC,CAC3D,GAAA,CACM,QAAA,IAAI,iCAAkCA,CAAI,EAG5C,MAAA8B,EAAS,MAAMC,EAAiB,EAE9B,QAAA,IAAI,wCAAyCD,CAAM,EAC3DE,EAAeF,CAAM,EAErB,MAAM7B,EAAe6B,EAAO,aACpB,QAAA,IAAI,wBAAyB7B,CAAY,EAGjD,MAAMgC,EAAclC,EAClBC,EACAC,EACA6B,EAAO,WACPA,EAAO,YACT,EACQ,eAAA,IAAI,0BAA2BG,CAAW,EAK3C,CACL,QAAS,GACT,KAJmB,MAAMC,EAAcD,EAAaH,EAAO,MAAM,CAKnE,QACOK,EAAO,CACN,cAAA,MAAM,wBAAyBA,CAAK,EACtCA,CAAA,CAEV,CAMA,eAAeJ,GAAwC,CACrD,OAAO,IAAI,QAAQ,CAACK,EAASC,IAAW,CACtC,OAAO,QAAQ,KAAK,IAClB,CAAC,SAAU,eAAgB,aAAc,cAAc,EACtDP,GAAW,CACN,GAAA,CACFE,EAAeF,CAAM,EACrBM,EAAQN,CAAoB,QACrBK,EAAO,CACdE,EAAOF,CAAK,CAAA,CACd,CAEJ,CAAA,CACD,CACH,CAOA,SAASH,EAAeM,EAA2D,CAC7E,GAAA,CAACA,EAAO,OACJ,MAAA,IAAI,MAAM,yFAAyF,EAGvG,GAAA,CAACA,EAAO,WACJ,MAAA,IAAI,MAAM,kFAAkF,EAGhG,GAAA,CAACA,EAAO,aACJ,MAAA,IAAI,MAAM,gFAAgF,EAG9F,GAAA,CAACA,EAAO,aACJ,MAAA,IAAI,MAAM,gFAAgF,CAEpG,CAQA,eAAeJ,EAAcK,EAAsBC,EAA8B,CAC/E,QAAQ,IAAI,gCAAgC,EACtC,MAAAC,EAAW,MAAM,MAAM,gEAAiE,CAC5F,OAAQ,OACR,QAAS,CACP,eAAgB,mBAChB,cAAiB,UAAUD,CAAM,EACnC,EACA,KAAM,KAAK,UAAUD,CAAO,CAAA,CAC7B,EAIG,GAFI,QAAA,IAAI,uBAAwBE,EAAS,MAAM,EAE/C,CAACA,EAAS,GAAI,CACV,MAAAC,EAAY,MAAMD,EAAS,KAAK,EAC9B,cAAA,MAAM,sBAAuBC,CAAS,EACxC,IAAI,MAAM,cAAcD,EAAS,MAAM,MAAMC,CAAS,EAAE,CAAA,CAG1D,MAAAC,EAAe,MAAMF,EAAS,KAAK,EACjC,eAAA,IAAI,wBAAyBE,CAAY,EAC1CA,CACT,CAOA,eAAelC,GAAmC,CAC5C,GAAA,CAEI,MAAA,OAAO,aAAa,UAAU,EAGpC,OAAO,aAAa,OAAO,CACzB,GAAI,YACJ,MAAO,oBACP,SAAU,CAAC,MAAM,CAAA,CAClB,EAED,OAAO,aAAa,OAAO,CACzB,GAAI,kBACJ,MAAO,+BACP,SAAU,CAAC,MAAM,CAAA,CAClB,EAED,OAAO,aAAa,OAAO,CACzB,GAAI,iBACJ,MAAO,yBACP,SAAU,CAAC,WAAW,CAAA,CACvB,EAED,QAAQ,IAAI,oCAAoC,QACzC0B,EAAO,CACN,QAAA,MAAM,kCAAmCA,CAAK,CAAA,CAE1D,CAKA,eAAeV,EACbH,EACAE,EACe,CACX,GAAA,CACF,MAAMM,EAAS,MAAMD,EAAWP,EAAQ,IAAI,EAC5CE,EAAaM,CAAM,QACZK,EAAO,CACDX,EAAA,CACX,QAAS,GACT,MAAOW,aAAiB,MAAQA,EAAM,QAAU,wBAAA,CACjD,CAAA,CAEL,CAKA,eAAeT,EACbJ,EACAE,EACe,CACX,GAAA,CAEI,MAAA,OAAO,UAAU,cAAc,CACnC,OAAQ,CAAE,MAAOF,EAAQ,KAAM,EAC/B,MAAO,CAAC,YAAY,CAAA,CACrB,EAQYE,EAAA,CAAE,QAAS,GAAM,QACvBW,EAAO,CACN,QAAA,MAAM,2BAA4BA,CAAK,EAClCX,EAAA,CACX,QAAS,GACT,MAAOW,aAAiB,MAAQA,EAAM,QAAU,0BAAA,CACjD,CAAA,CAEL,CAKA,eAAeR,EACbL,EACAE,EACe,CACX,GAAA,CACF,MAAMM,EAAS,MAAMc,EAAiBtB,EAAQ,KAAK,EACnDE,EAAaM,CAAM,QACZK,EAAO,CACDX,EAAA,CACX,QAAS,GACT,MAAOW,aAAiB,MAAQA,EAAM,QAAU,mBAAA,CACjD,CAAA,CAEL,CAKA,eAAeP,EACbN,EACAE,EACe,CACX,GAAA,CAGI,MAAAE,EAAoB,CAAE,OAAQ,gBAAiB,MAAOJ,EAAQ,OAAUmB,GAAa,CACrFA,EAAS,SAEJ,OAAA,KAAK,YAAYnB,EAAQ,MAAO,CACrC,OAAQ,iBAAA,CACT,CACH,CACD,EAEYE,EAAA,CAAE,QAAS,GAAM,QACvBW,EAAO,CACDX,EAAA,CACX,QAAS,GACT,MAAOW,aAAiB,MAAQA,EAAM,QAAU,wBAAA,CACjD,CAAA,CAEL,CAKA,eAAenB,EAAgB6B,EAA8B,CACvD,GAAA,CACI,MAAAf,EAAS,MAAMc,EAAiBC,CAAK,EAGvCf,EAAO,QACTgB,EAAiB,mCAAoC,SAAS,EAE7CA,EAAAhB,EAAO,OAAS,cAAe,OAAO,QAElDK,EAAO,CACN,QAAA,MAAM,oBAAqBA,CAAK,EACxCW,EAAiB,oBAAqB,OAAO,CAAA,CAEjD,CAKA,eAAe5B,EAAoB2B,EAA8B,CAC3D,GAAA,CAEF,MAAMnB,EAAoB,CAAE,OAAQ,gBAAiB,MAAAmB,CAAM,EAAIJ,GAAa,CACtEA,EAAS,QAEJ,OAAA,KAAK,YAAYI,EAAO,CAC7B,OAAQ,iBAAA,CACT,EAEDC,EAAiB,8BAA+B,OAAO,CACzD,CACD,QACMX,EAAO,CACN,QAAA,MAAM,yBAA0BA,CAAK,EAC7CW,EAAiB,8BAA+B,OAAO,CAAA,CAE3D,CAKA,eAAe/B,EAA0B8B,EAAe/B,EAAoC,CACtF,GAAA,CAEI,MAAAiC,EAAW,MAAMC,EAAmBH,CAAK,EAC/C,GAAIE,EAAU,CAEZA,EAAS,MAAQjC,EACX,MAAAgB,EAAS,MAAMD,EAAWkB,CAAQ,EAEpCjB,EAAO,QACQgB,EAAA,mCAAmChC,CAAW,IAAK,SAAS,EAE5DgC,EAAAhB,EAAO,OAAS,cAAe,OAAO,CACzD,QAEKK,EAAO,CACN,QAAA,MAAM,gCAAiCA,CAAK,EACpDW,EAAiB,gCAAiC,OAAO,CAAA,CAE7D,CAKA,eAAezB,EAAoBwB,EAAeI,EAAsC,CAClF,GAAA,CAEF,MAAMF,EAAW,MAAMC,EAAmBH,EAAO,CAAE,eAAgB,GAAO,EAC1E,GAAIE,EAAU,CAEZA,EAAS,QAAUE,EACVF,EAAA,MAAQ,kBAAkBA,EAAS,KAAK,GAE3C,MAAAjB,EAAS,MAAMD,EAAWkB,CAAQ,EAEpCjB,EAAO,QACTgB,EAAiB,wCAAyC,SAAS,EAElDA,EAAAhB,EAAO,OAAS,cAAe,OAAO,CACzD,QAEKK,EAAO,CACN,QAAA,MAAM,wBAAyBA,CAAK,EAC5CW,EAAiB,wBAAyB,OAAO,CAAA,CAErD,CAKA,eAAeF,EAAiBC,EAAsC,CAChE,GAAA,CACI,MAAAE,EAAW,MAAMC,EAAmBH,CAAK,EAC/C,GAAI,CAACE,EACG,MAAA,IAAI,MAAM,gCAAgC,EAG3C,OAAA,MAAMlB,EAAWkB,CAAQ,QACzBZ,EAAO,CACP,MAAA,CACL,QAAS,GACT,MAAOA,aAAiB,MAAQA,EAAM,QAAU,mBAClD,CAAA,CAEJ,CAKA,eAAea,EACbH,EACAK,EAAgE,GACtC,CACnB,OAAA,IAAI,QAASd,GAAY,CAC9B,MAAMe,EAAiB,CACrB,eAAgBD,EAAQ,gBAAkB,GAC1C,aAAcA,EAAQ,cAAgB,EACxC,EAEA,OAAO,KAAK,YACVL,EACA,CAAE,OAAQ,iBAAkB,QAASM,CAAe,EACnDV,GAAa,CACR,GAAA,OAAO,QAAQ,UAAW,CAC5B,QAAQ,MAAM,4BAA6B,OAAO,QAAQ,SAAS,EACnEL,EAAQ,IAAI,EACZ,MAAA,CAGEK,GAAY,CAACA,EAAS,MAChBL,EAAA,CACN,IAAKK,EAAS,IACd,MAAOA,EAAS,MAChB,OAAQA,EAAS,OACjB,YAAaA,EAAS,YACtB,QAASA,EAAS,OAAA,CACnB,GAEO,QAAA,MAAM,6BAA8BA,GAAU,OAAO,EAC7DL,EAAQ,IAAI,EACd,CAEJ,CAAA,CACD,CACH,CAKA,SAASU,EAAiBM,EAAiBC,EAA4B,UAAiB,CACtF,MAAMC,EAAiB,QAAQ,KAAK,IAAK,CAAA,GAElC,OAAA,cAAc,OAAOA,EAAgB,CAC1C,KAAM,QACN,QAAS,oBACT,MAAO,eACP,QAAAF,CAAA,CACD,EAGD,WAAW,IAAM,CACR,OAAA,cAAc,MAAME,CAAc,GACxC,GAAI,CACT"}